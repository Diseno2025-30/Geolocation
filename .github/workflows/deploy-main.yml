name: Deploy Flask App to 4 EC2 Instances

on:
  push:
    branches: [ main ]
    paths:
      # Se activa si hay cambios en el proyecto o el propio workflow
      - 'Proyecto_1_Diseno/**'
      - '.github/workflows/deploy-main.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false # Si un despliegue falla, los otros continuar√°n.
      matrix:
        # Define las 4 instancias en las que se desplegar√°
        instance: [1, 2, 3, 4]

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Deploy to EC2 Instance ${{ matrix.instance }}
      env:
        # Selecciona los secretos de GitHub din√°micamente para cada instancia
        HOST: ${{ secrets[format('EC2_HOST_{0}', matrix.instance)] }}
        USER: ${{ secrets[format('EC2_USER_{0}', matrix.instance)] }}
        KEY: ${{ secrets[format('EC2_SSH_KEY_{0}', matrix.instance)] }}
        ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', matrix.instance)] }}
        DOMAIN_BASE: tumaquinaya.com
      run: |
        echo "üöÄ Iniciando despliegue en la instancia ${{ matrix.instance }}..."
        
        # Crear el archivo de llave SSH temporalmente
        echo "$KEY" > deploy_key
        chmod 600 deploy_key
        
        # Crear archivo .env temporal con expansi√≥n de variable
        echo "$ENV_FILE" > temp_env_file
        
        # Extraer el NAME del archivo .env para usarlo como subdominio
        NAME_VALUE=$(grep "^NAME=" temp_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | tr '[:upper:]' '[:lower:]' | xargs)
        
        if [ -z "$NAME_VALUE" ]; then
            echo "‚ö†Ô∏è No se encontr√≥ NAME en .env, usando instance-${{ matrix.instance }}"
            NAME_VALUE="instance-${{ matrix.instance }}"
        fi
        
        # Construir el dominio completo
        FULL_DOMAIN="${NAME_VALUE}.${DOMAIN_BASE}"
        
        echo "üìã Configuraci√≥n detectada:"
        echo "   - NAME (subdominio): ${NAME_VALUE}"
        echo "   - Dominio completo: ${FULL_DOMAIN}"
        echo "   - IP del servidor: ${HOST}"
        
        # ========== SCRIPT OSRM - PUERTO DE BARRANQUILLA ==========
        cat > setup_osrm.sh << 'OSRMEOF'
        #!/bin/bash
        set -e
        
        echo "üó∫Ô∏è ========================================="
        echo "üó∫Ô∏è CONFIGURANDO OSRM - PUERTO DE BARRANQUILLA"
        echo "üó∫Ô∏è ========================================="
        
        # Verificar si OSRM ya est√° instalado y corriendo
        if docker ps 2>/dev/null | grep -q osrm-backend; then
          echo "‚úÖ OSRM ya est√° corriendo correctamente"
          docker ps | grep osrm-backend
          echo ""
          echo "üß™ Probando conectividad OSRM..."
          if curl -s -f http://localhost:5001/nearest/v1/driving/-74.8,10.98 > /dev/null 2>&1; then
            echo "‚úÖ OSRM responde correctamente"
          else
            echo "‚ö†Ô∏è OSRM no responde, reiniciando..."
            docker restart osrm-backend
            sleep 5
          fi
          exit 0
        fi
        
        echo "üì¶ Instalando dependencias..."
        
        # Instalar Docker si no est√° instalado
        if ! command -v docker &> /dev/null; then
          echo "üê≥ Instalando Docker..."
          sudo apt-get update -qq
          sudo apt-get install -y docker.io
          sudo systemctl start docker
          sudo systemctl enable docker
          echo "‚úÖ Docker instalado"
        else
          echo "‚úÖ Docker ya est√° instalado"
        fi
        
        # Instalar osmium-tool para convertir formatos
        if ! command -v osmium &> /dev/null; then
          echo "üîß Instalando osmium-tool..."
          sudo apt-get update -qq
          sudo apt-get install -y osmium-tool
          echo "‚úÖ osmium-tool instalado"
        else
          echo "‚úÖ osmium-tool ya est√° instalado"
        fi
        
        # ========== PERMISOS DE DOCKER ==========
        echo "üîß Configurando permisos de Docker..."
        
        if ! groups $USER | grep -q docker; then
          echo "   Agregando usuario '$USER' al grupo docker..."
          sudo usermod -aG docker $USER
        else
          echo "   Usuario '$USER' ya est√° en el grupo docker"
        fi
        
        echo "   Reiniciando Docker daemon..."
        sudo systemctl restart docker
        sleep 2
        
        sudo chmod 666 /var/run/docker.sock
        echo "‚úÖ Permisos de Docker configurados"
        # =========================================
        
        # Crear directorio para datos OSRM
        OSRM_DIR="/opt/osrm-data"
        echo "üìÅ Creando directorio: ${OSRM_DIR}"
        sudo mkdir -p ${OSRM_DIR}
        sudo chown $USER:$USER ${OSRM_DIR}
        cd ${OSRM_DIR}
        
        # Verificar si el mapa del puerto ya est√° procesado
        if [ -f "puerto-barranquilla.osrm" ]; then
          echo "‚úÖ Mapa del puerto ya procesado, saltando descarga"
        else
          echo ""
          echo "üì• ========================================="
          echo "üì• DESCARGANDO MAPA DEL PUERTO"
          echo "üì• ========================================="
          echo ""
          echo "üó∫Ô∏è M√©todo: Overpass API con IDs espec√≠ficos"
          echo "   √Årea: Puerto de Barranquilla"
          echo "   Calles: ~75 v√≠as espec√≠ficas"
          echo "   Nodos: 6 nodos clave"
          echo "   Fuente: OpenStreetMap"
          echo ""
          
          # Limpiar descargas previas
          rm -f puerto-barranquilla.osm puerto-barranquilla.osm.pbf
          
          # Descargar usando Overpass API con los IDs exactos del puerto
          MAX_ATTEMPTS=5
          ATTEMPT=1

          echo "üåê Descargando desde Overpass API..."
          echo "   (Esto deber√≠a tardar 10-20 segundos)"
          echo ""

          # Query optimizada con los IDs exactos de las calles del puerto
          OVERPASS_QUERY='[out:xml][timeout:90];(way(id:110447827,962055972,183530006,100301189,250255381,1007963947,99509101,1211032219,1211032217,1211032218,1211032224,1211032225,1211032220,1141049217,1007248971,1007248970,100301186,613384233,1005153829,613384205,613384208,613384207,613384206,1006086573,1006126955,613384225,613384224,613384223,613384222,613384221,1006086571,1006086572,1006039189,613384220,1006039191,1007626213,1006039190,613384218,613384217,626724241,626724245,626724242,613384231,613384216,613384219,613384226,1006042462,613384227,613384228,613384204,1006042461,1007581441,1006039193,1006039192,1006042459,1007537492,1057537489,1007603926,1007603925,1211032216,1006062382,1006062385,1006062384,1006062383,1006062386,626724235,626724233,626724238,1007538907,1007538908,962055977,962055976,613384209);node(id:6402440891,1939277496,8899212525,1939277480,9282142137,9295853166););(._;>;);out body;'

          echo "$OVERPASS_QUERY" > /tmp/overpass_query.txt
          
          MAX_ATTEMPTS=5
          ATTEMPT=1

          until curl -L --connect-timeout 60 --max-time 120 \
            --retry 3 --retry-delay 5 \
            -d @/tmp/overpass_query.txt \
            "https://overpass-api.de/api/interpreter" \
            -o puerto-barranquilla.osm; do
            
            if [ $ATTEMPT -ge $MAX_ATTEMPTS ]; then
              echo ""
              echo "‚ùå Error: No se pudo descargar desde Overpass API"
              exit 1
            fi
            
            echo ""
            echo "‚ö†Ô∏è Intento $ATTEMPT de $MAX_ATTEMPTS fall√≥"
            echo "   Esperando 15 segundos antes de reintentar..."
            ATTEMPT=$((ATTEMPT+1))
            sleep 15
            rm -f puerto-barranquilla.osm
          done

          echo ""
          echo "‚úÖ Descarga completada desde Overpass API"
          FILE_SIZE=$(stat -c%s puerto-barranquilla.osm 2>/dev/null || stat -f%z puerto-barranquilla.osm)

          if [ $FILE_SIZE -lt 10000 ]; then
            echo "‚ö†Ô∏è Archivo muy peque√±o ($FILE_SIZE bytes)"
            
            # Intentar descomprimir si est√° en gzip
            if file puerto-barranquilla.osm | grep -q "gzip"; then
              echo "üì¶ Archivo comprimido, descomprimiendo..."
              mv puerto-barranquilla.osm puerto-barranquilla.osm.gz
              gunzip puerto-barranquilla.osm.gz
            fi
            
            echo "üìÑ Contenido del archivo:"
            head -50 puerto-barranquilla.osm
            echo ""
            exit 1
          fi
          
          echo "   Archivo: $(ls -lh puerto-barranquilla.osm | awk '{print $5}')"
          
          # ========== CONVERTIR DE OSM (XML) A OSM.PBF (BINARIO) ==========
          echo ""
          echo "üîÑ ========================================="
          echo "üîÑ CONVIRTIENDO FORMATO"
          echo "üîÑ ========================================="
          echo ""
          echo "   De: OSM (XML sin comprimir)"
          echo "   A:  OSM.PBF (binario comprimido)"
          echo "   Raz√≥n: OSRM requiere formato PBF"
          echo ""
          
          if ! osmium cat puerto-barranquilla.osm -o puerto-barranquilla.osm.pbf --overwrite; then
            echo "‚ùå Error convirtiendo formato OSM a PBF"
            exit 1
          fi
          
          echo "‚úÖ Conversi√≥n completada"
          echo "   Archivo OSM original: $(ls -lh puerto-barranquilla.osm 2>/dev/null | awk '{print $5}')"
          echo "   Archivo PBF comprimido: $(ls -lh puerto-barranquilla.osm.pbf | awk '{print $5}')"
          echo ""
          
          # Limpiar archivo XML
          echo "üßπ Limpiando archivo OSM original..."
          rm -f puerto-barranquilla.osm
          echo "üíæ Archivo final: $(ls -lh puerto-barranquilla.osm.pbf | awk '{print $5}')"
          
          # ========== PROCESAR CON OSRM ==========
          echo ""
          echo "‚öôÔ∏è ========================================="
          echo "‚öôÔ∏è PROCESANDO MAPA CON OSRM"
          echo "‚öôÔ∏è ========================================="
          echo ""
          echo "   Algoritmo: MLD (Multi-Level Dijkstra)"
          echo "   Perfil: Car (autom√≥viles)"
          echo "   Tiempo estimado: 10-20 segundos"
          echo ""
          
          echo "üìç Paso 1/3: Extracci√≥n de datos de rutas..."
          if ! docker run -t -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend \
            osrm-extract -p /opt/car.lua /data/puerto-barranquilla.osm.pbf; then
            echo "‚ùå Error en extracci√≥n OSRM"
            echo "üí° Verifica los logs arriba para m√°s detalles"
            exit 1
          fi
          echo "‚úÖ Extracci√≥n completada"
          
          echo ""
          echo "üóÇÔ∏è Paso 2/3: Particionamiento de grafo..."
          if ! docker run -t -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend \
            osrm-partition /data/puerto-barranquilla.osrm; then
            echo "‚ùå Error en particionamiento OSRM"
            exit 1
          fi
          echo "‚úÖ Particionamiento completado"
          
          echo ""
          echo "üé® Paso 3/3: Personalizaci√≥n de rutas..."
          if ! docker run -t -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend \
            osrm-customize /data/puerto-barranquilla.osrm; then
            echo "‚ùå Error en personalizaci√≥n OSRM"
            exit 1
          fi
          echo "‚úÖ Personalizaci√≥n completada"
          
          echo ""
          echo "‚úÖ Procesamiento OSRM completado exitosamente"
          
          # Limpiar archivo .osm.pbf para ahorrar espacio
          echo ""
          echo "üßπ Limpiando archivos temporales..."
          rm -f puerto-barranquilla.osm.pbf
          
          echo ""
          echo "üíæ Espacio utilizado:"
          du -sh ${OSRM_DIR}
          echo ""
          echo "üìÇ Archivos finales:"
          ls -lh ${OSRM_DIR}/ | grep puerto-barranquilla
        fi
        
        echo ""
        echo "üöÄ ========================================="
        echo "üöÄ INICIANDO SERVIDOR OSRM"
        echo "üöÄ ========================================="
        
        # Detener contenedor anterior si existe
        docker stop osrm-backend 2>/dev/null || true
        docker rm osrm-backend 2>/dev/null || true
        
        # Iniciar servidor OSRM en puerto 5001
        echo "   Puerto: 5001"
        echo "   Algoritmo: MLD"
        echo "   Auto-reinicio: Habilitado"
        echo ""
        
        docker run -d --name osrm-backend \
          --restart unless-stopped \
          -p 5001:5000 \
          -v "${PWD}:/data" \
          ghcr.io/project-osrm/osrm-backend \
          osrm-routed --algorithm mld /data/puerto-barranquilla.osrm
        
        # Esperar a que OSRM est√© listo
        echo "‚è≥ Esperando que OSRM est√© listo..."
        for i in {1..30}; do
          if curl -s -f http://localhost:5001/nearest/v1/driving/-74.8,10.98 > /dev/null 2>&1; then
            echo ""
            echo "‚úÖ OSRM est√° funcionando correctamente"
            break
          fi
          if [ $i -eq 30 ]; then
            echo ""
            echo "‚ùå Timeout esperando OSRM. Ver logs:"
            docker logs osrm-backend --tail 50
            exit 1
          fi
          echo -n "."
          sleep 2
        done
        
        echo ""
        echo "üîß Configurando servicio systemd para auto-inicio..."
        
        # Crear servicio systemd
        sudo tee /etc/systemd/system/osrm.service > /dev/null << SERVICEEOF
        [Unit]
        Description=OSRM Backend Service - Puerto de Barranquilla
        After=docker.service
        Requires=docker.service
        
        [Service]
        Type=simple
        User=$USER
        Restart=always
        RestartSec=10
        ExecStartPre=-/usr/bin/docker stop osrm-backend
        ExecStartPre=-/usr/bin/docker rm osrm-backend
        ExecStart=/usr/bin/docker run --rm --name osrm-backend -p 5001:5000 -v ${OSRM_DIR}:/data ghcr.io/project-osrm/osrm-backend osrm-routed --algorithm mld /data/puerto-barranquilla.osrm
        ExecStop=/usr/bin/docker stop osrm-backend
        
        [Install]
        WantedBy=multi-user.target
        SERVICEEOF
        
        sudo systemctl daemon-reload
        sudo systemctl enable osrm
        
        echo "‚úÖ Servicio systemd configurado"
        
        # Prueba final
        echo ""
        echo "üß™ ========================================="
        echo "üß™ PRUEBA DE SNAP-TO-ROADS"
        echo "üß™ ========================================="
        echo ""
        
        RESPONSE=$(curl -s http://localhost:5001/nearest/v1/driving/-74.8,10.98)
        if echo "$RESPONSE" | grep -q "Ok"; then
          echo "‚úÖ Snap-to-roads funcionando correctamente"
          echo ""
          echo "üìç Prueba realizada:"
          echo "   Coordenada original: (-74.8, 10.98)"
          echo "   Ubicaci√≥n: Puerto de Barranquilla"
          echo "   Resultado: Ajustada a la calle m√°s cercana del puerto"
        else
          echo "‚ö†Ô∏è Respuesta inesperada de OSRM:"
          echo "$RESPONSE"
        fi
        
        echo ""
        echo "========================================="
        echo "‚úÖ INSTALACI√ìN COMPLETADA"
        echo "========================================="
        echo ""
        echo "üìä INFORMACI√ìN DEL SISTEMA:"
        echo "   - URL local: http://localhost:5001"
        echo "   - Directorio: ${OSRM_DIR}"
        echo "   - Mapa: Puerto de Barranquilla"
        echo "   - Calles: ~75 v√≠as espec√≠ficas"
        echo "   - Fuente: OpenStreetMap (IDs espec√≠ficos)"
        echo "   - Algoritmo: MLD (Multi-Level Dijkstra)"
        echo "   - Espacio usado: $(du -sh ${OSRM_DIR} | cut -f1)"
        echo ""
        echo "üó∫Ô∏è COBERTURA:"
        echo "   ‚úÖ Carrera 30"
        echo "   ‚úÖ Calle 1F, Calle 2, Calle 4"
        echo "   ‚úÖ Carrera 38"
        echo "   ‚úÖ V√≠as internas del puerto (~70 calles)"
        echo "   ‚úÖ 6 nodos clave de intersecci√≥n"
        echo ""
        echo "üß™ COMANDOS DE PRUEBA:"
        echo "   # Snap-to-roads en el puerto"
        echo "   curl 'http://localhost:5001/nearest/v1/driving/-74.8,10.98'"
        echo ""
        echo "   # Ruta dentro del puerto"
        echo "   curl 'http://localhost:5001/route/v1/driving/-74.8,10.98;-74.79,10.97'"
        echo ""
        echo "   # Match (ajustar trayectoria GPS)"
        echo "   curl 'http://localhost:5001/match/v1/driving/-74.8,10.98;-74.795,10.975;-74.79,10.97'"
        echo ""
        echo "üõ†Ô∏è COMANDOS √öTILES:"
        echo "   docker logs -f osrm-backend     # Ver logs en tiempo real"
        echo "   docker restart osrm-backend     # Reiniciar servidor"
        echo "   systemctl status osrm           # Estado del servicio"
        echo "   docker stats osrm-backend       # Monitorear recursos"
        echo ""
        echo "üìö DOCUMENTACI√ìN:"
        echo "   API OSRM: https://project-osrm.org/docs/v5.24.0/api/"
        echo "========================================="
        OSRMEOF
        # ========== FIN SCRIPT OSRM ==========
        
        # Transferir script de despliegue y ejecutarlo
        echo "üìù Creando script de despliegue remoto..."
        cat > deploy_remote.sh << 'DEPLOYEOF'
        #!/bin/bash
        set -e

        # Recibir par√°metros
        SUBDOMAIN="${1}"
        DOMAIN_BASE="${2}"
        INSTANCE_NUM="${3}"

        echo "üîß Configuraci√≥n recibida:"
        echo "   - Subdominio: ${SUBDOMAIN}"
        echo "   - Dominio base: ${DOMAIN_BASE}"
        echo "   - Instancia: ${INSTANCE_NUM}"

        # Determinar ruta del proyecto
        if [ -d "/home/ubuntu/Web-server-UDP" ]; then
          echo "üìÅ Usando proyecto existente en /home/ubuntu/Web-server-UDP"
          cd /home/ubuntu/Web-server-UDP
        else
          echo "üìÅ Usando/creando estructura en /opt/location-tracker"
          sudo mkdir -p /opt/location-tracker
          sudo chown $USER:$USER /opt/location-tracker
          cd /opt/location-tracker
        fi

        # Guardar commit actual antes de actualizar
        echo "üì¶ Actualizando c√≥digo desde Git..."
        if [ -d .git ]; then
          BEFORE_PULL=$(git rev-parse HEAD 2>/dev/null || echo "none")
          git fetch origin main
          git reset --hard origin/main
          AFTER_PULL=$(git rev-parse HEAD)
          
          if [ "$BEFORE_PULL" != "$AFTER_PULL" ]; then
            echo "‚úÖ C√≥digo actualizado exitosamente"
            echo "Cambios aplicados:"
            if [ "$BEFORE_PULL" != "none" ]; then
              git log --oneline ${BEFORE_PULL}..${AFTER_PULL} | head -10
            fi
            CODE_UPDATED=true
          else
            echo "‚ÑπÔ∏è Ya tienes la √∫ltima versi√≥n del c√≥digo"
            CODE_UPDATED=false
          fi
        else
          echo "üì• Clonando repositorio por primera vez..."
          git clone https://github.com/Diseno2025-30/Geolocation.git .
          CODE_UPDATED=true
        fi

        # Navegar al directorio del proyecto
        cd Proyecto_1_Diseno

        # Determinar ruta completa
        PROJECT_PATH=$(pwd)
        echo "üìÇ Trabajando en: $PROJECT_PATH"

        # Verificar el archivo .env
        echo "üìã Verificando archivo .env..."
        if [ -f .env ]; then
          source .env 2>/dev/null || true
          
          # Si tenemos NAME del .env, √∫salo
          if [ ! -z "$NAME" ]; then
            SUBDOMAIN=$(echo "$NAME" | tr '[:upper:]' '[:lower:]' | xargs)
            echo "‚úÖ Usando NAME del .env: ${NAME} -> ${SUBDOMAIN}"
          fi
        fi

        # Construir nombres finales
        FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
        APP_NAME="flask-app-${SUBDOMAIN}"

        echo "üìä Configuraci√≥n final:"
        echo "   - APP_NAME: ${APP_NAME}"
        echo "   - FULL_DOMAIN: ${FULL_DOMAIN}"
        echo "   - PROJECT_PATH: ${PROJECT_PATH}"

        # Instalar dependencias del sistema si es necesario
        echo "üì¶ Verificando dependencias del sistema..."

        # Node.js y npm
        if ! command -v node &> /dev/null; then
          echo "Instalando Node.js..."
          curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
          sudo apt-get install -y nodejs
        fi

        # PM2
        if ! command -v pm2 &> /dev/null; then
          echo "Instalando PM2..."
          sudo npm install -g pm2
          pm2 startup systemd -u $USER --hp /home/$USER
        else
          echo "üîÑ Actualizando PM2 a la √∫ltima versi√≥n..."
          sudo npm update -g pm2
        fi

        # Python, Nginx y Certbot
        sudo apt-get update -qq
        sudo apt-get install -y python3-pip python3-venv nginx certbot python3-certbot-nginx

        # Configurar entorno virtual de Python
        echo "üêç Configurando entorno Python..."
        if [ ! -d "venv" ]; then
          python3 -m venv venv
          echo "‚úÖ Entorno virtual creado"
        fi

        source venv/bin/activate
        pip install --upgrade pip
        pip install flask psycopg2-binary python-dotenv requests

        # Si existe requirements.txt, instalarlo tambi√©n
        if [ -f requirements.txt ]; then
          pip install -r requirements.txt
        fi

        # Configurar Nginx PRIMERO sin SSL (necesario para validaci√≥n de Let's Encrypt)
        echo "üåê Configurando Nginx (paso 1: HTTP temporal para validaci√≥n SSL)..."
        cat > /tmp/nginx-config-temp << NGINXTEMPCONF
        server {
            listen 80;
            server_name ${FULL_DOMAIN} www.${FULL_DOMAIN};
            
            # Location para validaci√≥n de Let's Encrypt
            location /.well-known/acme-challenge/ {
                root /var/www/certbot;
            }
            
            location / {
                proxy_pass http://localhost:5000;
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_connect_timeout 60s;
                proxy_send_timeout 60s;
                proxy_read_timeout 60s;
                proxy_buffering off;
            }
        }
        NGINXTEMPCONF

        # Crear directorio para validaci√≥n de Let's Encrypt
        sudo mkdir -p /var/www/certbot

        sudo mv /tmp/nginx-config-temp /etc/nginx/sites-available/location-tracker
        sudo ln -sf /etc/nginx/sites-available/location-tracker /etc/nginx/sites-enabled/
        sudo rm -f /etc/nginx/sites-enabled/default

        if sudo nginx -t; then
          sudo systemctl reload nginx
          echo "‚úÖ Nginx configurado temporalmente para validaci√≥n SSL"
        else
          echo "‚ùå Error en configuraci√≥n de Nginx"
          exit 1
        fi

        # Obtener certificado SSL con Let's Encrypt
        echo "üîê Obteniendo certificado SSL con Let's Encrypt..."
        
        # Verificar si ya existe un certificado v√°lido
        if sudo test -f "/etc/letsencrypt/live/${FULL_DOMAIN}/fullchain.pem"; then
          echo "üìú Certificado SSL existente encontrado, intentando renovar si es necesario..."
          sudo certbot renew --nginx --non-interactive --quiet || true
        else
          echo "üÜï Obteniendo nuevo certificado SSL..."
          # Obtener certificado SSL (usa --staging para pruebas, qu√≠talo en producci√≥n)
          sudo certbot certonly \
            --webroot \
            -w /var/www/certbot \
            --non-interactive \
            --agree-tos \
            --email oliverproace@gmail.com \
            -d ${FULL_DOMAIN} \
            -d www.${FULL_DOMAIN} \
            || echo "‚ö†Ô∏è No se pudo obtener certificado SSL, continuando con configuraci√≥n HTTP"
        fi

        # Configurar Nginx con SSL y redirecci√≥n HTTPS forzada
        echo "üîí Configurando Nginx con SSL y HTTPS forzado..."
        
        # Verificar si el certificado existe
        if sudo test -f "/etc/letsencrypt/live/${FULL_DOMAIN}/fullchain.pem"; then
          echo "‚úÖ Certificado SSL encontrado, configurando HTTPS..."
          
          cat > /tmp/nginx-config-ssl << NGINXSSLCONF
        # Redirecci√≥n HTTP a HTTPS (FORZADO)
        server {
            listen 80;
            server_name ${FULL_DOMAIN} www.${FULL_DOMAIN};
            
            # Permitir renovaci√≥n de certificados
            location /.well-known/acme-challenge/ {
                root /var/www/certbot;
            }
            
            # Redireccionar TODO el tr√°fico HTTP a HTTPS
            location / {
                return 301 https://\$host\$request_uri;
            }
        }

        # Configuraci√≥n HTTPS principal
        server {
            listen 443 ssl http2;
            server_name ${FULL_DOMAIN};
            
            # Certificados SSL
            ssl_certificate /etc/letsencrypt/live/${FULL_DOMAIN}/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/${FULL_DOMAIN}/privkey.pem;
            
            # Configuraci√≥n SSL moderna y segura
            ssl_protocols TLSv1.2 TLSv1.3;
            ssl_ciphers HIGH:!aNULL:!MD5;
            ssl_prefer_server_ciphers on;
            
            # Seguridad adicional
            ssl_session_cache shared:SSL:10m;
            ssl_session_timeout 10m;
            ssl_stapling on;
            ssl_stapling_verify on;
            
            # Headers de seguridad
            add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
            add_header X-Frame-Options "SAMEORIGIN" always;
            add_header X-Content-Type-Options "nosniff" always;
            add_header X-XSS-Protection "1; mode=block" always;
            
            access_log /var/log/nginx/${SUBDOMAIN}_ssl_access.log;
            error_log /var/log/nginx/${SUBDOMAIN}_ssl_error.log;
            
            location / {
                proxy_pass http://localhost:5000;
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto https;
                proxy_set_header X-Forwarded-SSL on;
                proxy_connect_timeout 60s;
                proxy_send_timeout 60s;
                proxy_read_timeout 60s;
                proxy_buffering off;
                
                # Websocket support
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection "upgrade";
            }
            
            location /static {
                alias ${PROJECT_PATH}/static;
                expires 30d;
                add_header Cache-Control "public, immutable";
            }
        }

        # Redirecci√≥n de www a no-www con HTTPS
        server {
            listen 443 ssl http2;
            server_name www.${FULL_DOMAIN};
            
            ssl_certificate /etc/letsencrypt/live/${FULL_DOMAIN}/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/${FULL_DOMAIN}/privkey.pem;
            
            return 301 https://${FULL_DOMAIN}\$request_uri;
        }
        NGINXSSLCONF
          
          sudo mv /tmp/nginx-config-ssl /etc/nginx/sites-available/location-tracker
          
        else
          echo "‚ö†Ô∏è No se encontr√≥ certificado SSL, manteniendo configuraci√≥n HTTP con advertencia..."
          echo "‚ö†Ô∏è ADVERTENCIA: La aplicaci√≥n est√° corriendo en HTTP. Configure DNS y vuelva a ejecutar para SSL."
        fi

        if sudo nginx -t; then
          sudo systemctl reload nginx
          echo "‚úÖ Nginx configurado correctamente"
        else
          echo "‚ùå Error en configuraci√≥n de Nginx"
          exit 1
        fi

        # Configurar renovaci√≥n autom√°tica de certificados SSL
        echo "üìÖ Configurando renovaci√≥n autom√°tica de certificados SSL..."
        
        # Crear script de renovaci√≥n
        cat > /tmp/renew-ssl.sh << 'RENEWSCRIPT'
        #!/bin/bash
        certbot renew --nginx --non-interactive --quiet
        if [ $? -eq 0 ]; then
          systemctl reload nginx
        fi
        RENEWSCRIPT
        
        sudo mv /tmp/renew-ssl.sh /etc/letsencrypt/renew-ssl.sh
        sudo chmod +x /etc/letsencrypt/renew-ssl.sh
        
        # Agregar cron job para renovaci√≥n autom√°tica (dos veces al d√≠a)
        CRON_JOB="0 0,12 * * * root /etc/letsencrypt/renew-ssl.sh"
        if ! sudo grep -q "/etc/letsencrypt/renew-ssl.sh" /etc/crontab; then
          echo "$CRON_JOB" | sudo tee -a /etc/crontab > /dev/null
          echo "‚úÖ Cron job para renovaci√≥n autom√°tica configurado"
        fi

        # Crear script de inicio si no existe o si hay cambios en el c√≥digo
        if [ ! -f "start_app.sh" ] || [ "$CODE_UPDATED" = "true" ]; then
          echo "üìù Actualizando script de inicio..."
          cat > start_app.sh << 'STARTSCRIPT'
        #!/bin/bash
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        cd "$SCRIPT_DIR"
        source venv/bin/activate
        export FLASK_APP=udp_flask_server.py
        export FLASK_ENV=production
        # Configurar Flask para confiar en headers de proxy (importante para HTTPS)
        export FLASK_TRUSTED_PROXIES="127.0.0.1"
        python udp_flask_server.py
        STARTSCRIPT
          chmod +x start_app.sh
        fi

        # IMPORTANTE: Limpiar aplicaciones PM2 antiguas que puedan estar en conflicto
        echo "üßπ Limpiando aplicaciones PM2 antiguas..."

        
        # Primero, detener TODAS las aplicaciones Flask antiguas que puedan estar usando el puerto
        pm2 list | grep -E "flask-app-[0-9]+" | awk '{print $2}' | while read old_app; do
          if [ "$old_app" != "$APP_NAME" ]; then
            echo "Deteniendo aplicaci√≥n antigua: $old_app"
            pm2 stop "$old_app" 2>/dev/null || true
            pm2 delete "$old_app" 2>/dev/null || true
          fi
        done

        # Tambi√©n detener cualquier flask-app-{numero} que pueda estar corriendo
        pm2 stop "flask-app-${INSTANCE_NUM}" 2>/dev/null || true
        pm2 delete "flask-app-${INSTANCE_NUM}" 2>/dev/null || true

        # Matar cualquier proceso Python que est√© usando el puerto 5000
        echo "üîç Verificando puerto 5000..."
        if sudo lsof -i :5000 &>/dev/null; then
          echo "‚ö†Ô∏è Puerto 5000 en uso, liber√°ndolo..."
          sudo fuser -k 5000/tcp 2>/dev/null || true
          sleep 2
        fi

        # Gestionar la aplicaci√≥n PM2 (VERSI√ìN CORREGIDA)
        PM2_APP_EXISTS=$(pm2 list | grep " ${APP_NAME} " | awk '{print $2}' || echo "")

        if [ ! -z "$PM2_APP_EXISTS" ]; then
          if [ "$CODE_UPDATED" = "true" ]; then
            echo "üîÑ C√≥digo actualizado, reiniciando aplicaci√≥n ${APP_NAME}..."
            pm2 restart ${APP_NAME} --update-env
          else
            echo "‚ÑπÔ∏è Aplicaci√≥n ${APP_NAME} ya est√° ejecut√°ndose (sin cambios en c√≥digo)"
          fi
        else
          echo "üÜï Iniciando nueva aplicaci√≥n ${APP_NAME}..."
          pm2 start start_app.sh --name ${APP_NAME} --interpreter bash --cwd $PROJECT_PATH
        fi

        # Guardar configuraci√≥n de PM2
        pm2 save

        # Esperar y verificar
        echo "‚è≥ Esperando a que la aplicaci√≥n est√© lista..."
        sleep 5

        # Verificaci√≥n de estado
        echo "üìä Estado de la aplicaci√≥n:"
        pm2 status ${APP_NAME}

        # Mostrar √∫ltimos logs
        echo "üìÑ √öltimos logs:"
        pm2 logs ${APP_NAME} --lines 15 --nostream || true

        # Tests de conectividad
        echo "üß™ Realizando pruebas de conectividad..."

        # Test Flask
        MAX_RETRIES=5
        RETRY=0
        while [ $RETRY -lt $MAX_RETRIES ]; do
          if curl -s -f http://localhost:5000/ > /dev/null 2>&1; then
            echo "‚úÖ Flask respondiendo correctamente en puerto 5000"
            break
          else
            RETRY=$((RETRY + 1))
            if [ $RETRY -lt $MAX_RETRIES ]; then
              echo "‚è≥ Esperando a Flask (intento $RETRY/$MAX_RETRIES)..."
              sleep 2
            else
              echo "‚ö†Ô∏è Flask no responde despu√©s de $MAX_RETRIES intentos"
              echo "Debug - Procesos Python:"
              ps aux | grep python | grep -v grep || true
              echo "Debug - Puerto 5000:"
              sudo netstat -tlnp | grep :5000 || true
            fi
          fi
        done

        # Test HTTPS si el certificado existe
        if sudo test -f "/etc/letsencrypt/live/${FULL_DOMAIN}/fullchain.pem"; then
          echo "üîê Verificando HTTPS..."
          
          # Test redirecci√≥n HTTP a HTTPS
          REDIRECT_TEST=$(curl -s -o /dev/null -w "%{http_code}" -L http://localhost/ 2>/dev/null || echo "000")
          if [ "$REDIRECT_TEST" = "200" ]; then
            echo "‚úÖ Redirecci√≥n HTTP ‚Üí HTTPS funcionando"
          else
            echo "‚ö†Ô∏è Verificaci√≥n de redirecci√≥n devolvi√≥ c√≥digo: $REDIRECT_TEST"
          fi
          
          # Test HTTPS directo (si es posible)
          if curl -s -f -k https://localhost/ > /dev/null 2>&1; then
            echo "‚úÖ HTTPS respondiendo correctamente"
          else
            echo "‚ÑπÔ∏è HTTPS configurado pero requiere dominio v√°lido para prueba completa"
          fi
        else
          echo "‚ö†Ô∏è SSL no configurado - acceso solo por HTTP"
        fi

        # Configurar firewall
        if command -v ufw &> /dev/null; then
          echo "üîí Configurando firewall..."
          sudo ufw allow 80/tcp comment "HTTP (redirige a HTTPS)" 2>/dev/null || true
          sudo ufw allow 443/tcp comment "HTTPS" 2>/dev/null || true
          sudo ufw allow 5049/udp comment "UDP Listener" 2>/dev/null || true
          sudo ufw allow 22/tcp comment "SSH" 2>/dev/null || true
        fi

        # Resumen final
        echo ""
        echo "========================================="
        if [ "$CODE_UPDATED" = "true" ]; then
          echo "üéâ C√ìDIGO ACTUALIZADO Y DESPLEGADO"
        else
          echo "‚úÖ DESPLIEGUE VERIFICADO"
        fi
        echo "========================================="
        echo ""
        echo "üìä CONFIGURACI√ìN:"
        echo "   - Aplicaci√≥n: ${APP_NAME}"
        echo "   - Dominio: ${FULL_DOMAIN}"
        echo "   - Proyecto: ${PROJECT_PATH}"
        echo "   - Estado: $(pm2 list | grep ${APP_NAME} | awk '{print $10}')"
        
        if sudo test -f "/etc/letsencrypt/live/${FULL_DOMAIN}/fullchain.pem"; then
          echo "   - SSL: ‚úÖ Configurado (HTTPS forzado)"
          echo ""
          echo "üîê CERTIFICADO SSL:"
          sudo certbot certificates 2>/dev/null | grep -A 3 "${FULL_DOMAIN}" || true
        else
          echo "   - SSL: ‚ö†Ô∏è No configurado (solo HTTP)"
        fi
        
        echo ""
        echo "üîó ACCESO:"
        if sudo test -f "/etc/letsencrypt/live/${FULL_DOMAIN}/fullchain.pem"; then
          echo "   - https://${FULL_DOMAIN} (SEGURO)"
          echo "   - http://${FULL_DOMAIN} ‚Üí Redirige a HTTPS"
        else
          echo "   - http://${FULL_DOMAIN} (‚ö†Ô∏è Sin SSL)"
          echo "   - Para habilitar HTTPS: Configure DNS y vuelva a ejecutar"
        fi
        echo ""
        echo "üõ†Ô∏è COMANDOS √öTILES:"
        echo "   - Ver logs: pm2 logs ${APP_NAME}"
        echo "   - Reiniciar: pm2 restart ${APP_NAME}"
        echo "   - Recargar: pm2 reload ${APP_NAME}"
        echo "   - Monitorear: pm2 monit"
        echo "   - Renovar SSL: sudo certbot renew --nginx"
        echo "   - Ver certificados: sudo certbot certificates"
        echo ""
        echo "üìä Aplicaciones PM2 activas:"
        pm2 list
        echo ""
        echo "üîí SEGURIDAD:"
        echo "   - HTTPS: Forzado con redirecci√≥n 301"
        echo "   - HSTS: Habilitado (preload ready)"
        echo "   - TLS: v1.2 y v1.3 √∫nicamente"
        echo "   - Headers de seguridad: Configurados"
        echo "   - Renovaci√≥n SSL: Autom√°tica (cron)"
        echo "========================================="
        DEPLOYEOF
        
        # Transferir archivos al servidor
        echo "üì§ Transfiriendo archivos al servidor..."
        
        # Determinar la ruta del proyecto
        PROJECT_PATH=$(ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} '
          if [ -d "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno" ]; then
            echo "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno"
          else
            echo "/opt/location-tracker/Proyecto_1_Diseno"
          fi
        ')
        
        # Transferir .env
        scp -o StrictHostKeyChecking=no -i deploy_key temp_env_file ${USER}@${HOST}:${PROJECT_PATH}/.env
        
        # Transferir y ejecutar script
        scp -o StrictHostKeyChecking=no -i deploy_key deploy_remote.sh ${USER}@${HOST}:/tmp/deploy_remote.sh
        
        echo "üöÄ Ejecutando despliegue con SSL..."
        ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} \
          "chmod +x /tmp/deploy_remote.sh && /tmp/deploy_remote.sh '${NAME_VALUE}' '${DOMAIN_BASE}' '${{ matrix.instance }}' 'oliverproace@gmail.com' && rm /tmp/deploy_remote.sh"
        
        # Limpiar archivos temporales
        rm -f deploy_key temp_env_file deploy_remote.sh
        
        echo "‚úÖ Despliegue con SSL/HTTPS completado para instancia ${{ matrix.instance }}"