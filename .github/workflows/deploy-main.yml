name: Deploy Main to Self-Hosted Runners

on:
  push:
    branches: [main]
    paths:
      # Se activa solo cuando hay cambios en el proyecto principal
      - "Proyecto_1_Diseno/**"
      - ".github/workflows/deploy-main.yml"
      # Excluir la ruta /test
      - "!Proyecto_1_Diseno/test/**"

jobs:
  deploy:
    strategy:
      fail-fast: false # Si un despliegue falla, los otros continuarÃ¡n
      matrix:
        include:
          - runner: ec2-oliver-instance-1
            instance: 1
            name: oliver
            branch: Oliver-branch
          - runner: ec2-hernando-instance-2
            instance: 2
            name: hernando
            branch: Hernando-branch
          - runner: ec2-alan-instance-3
            instance: 3
            name: alan
            branch: Alan-branch
          - runner: ec2-sebastian-instance-4
            instance: 4
            name: sebastian
            branch: Sebastian-branch

    runs-on: ${{ matrix.runner }}

    steps:
      - name: ðŸŽ¯ Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Para poder ver el historial completo

      - name: ðŸ“‹ Display environment info
        run: |
          echo "ðŸƒ Running on self-hosted runner: ${{ matrix.runner }}"
          echo "ðŸ“¦ Instance: ${{ matrix.instance }}"
          echo "ðŸ‘¤ Name: ${{ matrix.name }}"
          echo "ðŸŒ¿ Branch: ${{ matrix.branch }}"
          echo "ðŸ“‚ Current directory: $(pwd)"
          echo "ðŸ–¥ï¸ Hostname: $(hostname)"
          echo "ðŸ‘¤ Running as user: $(whoami)"

      - name: ðŸ”§ Setup environment
        env:
          ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', matrix.instance)] }}
          DOMAIN_BASE: tumaquinaya.com
        run: |
          echo "ðŸš€ Iniciando configuraciÃ³n en instancia ${{ matrix.instance }}..."

          # Determinar ruta del proyecto
          if [ -d "/home/ubuntu/Web-server-UDP" ]; then
            PROJECT_BASE="/home/ubuntu/Web-server-UDP"
          else
            PROJECT_BASE="/opt/location-tracker"
            sudo mkdir -p $PROJECT_BASE
            sudo chown $USER:$USER $PROJECT_BASE
          fi

          PROJECT_PATH="${PROJECT_BASE}/Proyecto_1_Diseno"
          echo "PROJECT_PATH=${PROJECT_PATH}" >> $GITHUB_ENV

          # Crear directorio si no existe
          mkdir -p ${PROJECT_PATH}

          # Guardar el archivo .env temporalmente
          echo "$ENV_FILE" > /tmp/temp_env_${{ matrix.instance }}

          # Extraer el NAME del archivo .env
          NAME_VALUE=$(grep "^NAME=" /tmp/temp_env_${{ matrix.instance }} | cut -d'=' -f2 | tr -d '"' | tr -d "'" | tr '[:upper:]' '[:lower:]' | xargs)

          if [ -z "$NAME_VALUE" ]; then
              NAME_VALUE="${{ matrix.name }}"
          fi

          echo "NAME_VALUE=${NAME_VALUE}" >> $GITHUB_ENV
          echo "FULL_DOMAIN=${NAME_VALUE}.${DOMAIN_BASE}" >> $GITHUB_ENV
          echo "APP_NAME=flask-app-${NAME_VALUE}" >> $GITHUB_ENV

          echo "ðŸ“‹ ConfiguraciÃ³n detectada:"
          echo "   - NAME (subdominio): ${NAME_VALUE}"
          echo "   - Dominio completo: ${NAME_VALUE}.${DOMAIN_BASE}"
          echo "   - Ruta del proyecto: ${PROJECT_PATH}"

      - name: ðŸ“¥ Update main application code
        run: |
          cd ${PROJECT_PATH}

          # Si existe repositorio git
          if [ -d .git ]; then
            echo "ðŸ“¦ Actualizando cÃ³digo desde Git (preservando /test)..."
            
            # Guardar commit actual
            BEFORE_PULL=$(git rev-parse HEAD 2>/dev/null || echo "none")
            
            # Stash cambios locales si existen (especialmente en /test)
            git stash push -m "Auto-stash before deploy" -- test/ 2>/dev/null || true
            
            # Actualizar solo archivos del main, excluyendo test/
            git fetch origin main
            
            # Checkout selectivo - actualizar todo excepto test/
            git checkout origin/main -- . ':!test/' ':!Proyecto_1_Diseno/test/'
            
            AFTER_PULL=$(git rev-parse origin/main)
            
            # Restaurar cambios en /test si habÃ­a stash
            git stash pop 2>/dev/null || true
            
            if [ "$BEFORE_PULL" != "$AFTER_PULL" ]; then
              echo "âœ… CÃ³digo actualizado exitosamente (preservando /test)"
              echo "CODE_UPDATED=true" >> $GITHUB_ENV
            else
              echo "â„¹ï¸ Ya tienes la Ãºltima versiÃ³n del cÃ³digo"
              echo "CODE_UPDATED=false" >> $GITHUB_ENV
            fi
          else
            echo "ðŸ“¥ Clonando repositorio por primera vez..."
            cd ${PROJECT_BASE}
            git clone https://github.com/Diseno2025-30/Geolocation.git .
            cd ${PROJECT_PATH}
            echo "CODE_UPDATED=true" >> $GITHUB_ENV
          fi

          # Copiar el archivo .env al proyecto
          cp /tmp/temp_env_${{ matrix.instance }} .env

          # Verificar que /test no fue modificado
          if [ -d "test" ]; then
            echo "ðŸ“ Directorio /test preservado"
            ls -la test/ 2>/dev/null | head -5 || echo "Directorio vacÃ­o o sin acceso"
          fi

      - name: ðŸ Setup Python environment
        run: |
          cd ${PROJECT_PATH}

          echo "ðŸ Configurando entorno Python..."

          # Crear entorno virtual si no existe
          if [ ! -d "venv" ]; then
            python3 -m venv venv
            echo "âœ… Entorno virtual creado"
          fi

          # Activar y actualizar pip
          source venv/bin/activate
          pip install --upgrade pip

          # Instalar dependencias
          pip install flask psycopg2-binary python-dotenv

          # Si existe requirements.txt, instalarlo
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
            echo "âœ… Dependencias de requirements.txt instaladas"
          fi

      - name: ðŸ“ Create/Update startup script
        run: |
          cd ${PROJECT_PATH}

          cat > start_app.sh << 'STARTSCRIPT'
          #!/bin/bash
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          cd "$SCRIPT_DIR"
          source venv/bin/activate
          export FLASK_APP=udp_flask_server.py
          export FLASK_ENV=production
          export FLASK_TRUSTED_PROXIES="127.0.0.1"
          python udp_flask_server.py
          STARTSCRIPT

          chmod +x start_app.sh
          echo "âœ… Script de inicio actualizado"

      - name: ðŸŒ Configure Nginx
        run: |
          echo "ðŸŒ Configurando Nginx para ${FULL_DOMAIN}..."

          # Crear configuraciÃ³n de Nginx con SSL
          cat > /tmp/nginx-config << NGINXCONF
          # RedirecciÃ³n HTTP a HTTPS
          server {
              listen 80;
              server_name ${FULL_DOMAIN} www.${FULL_DOMAIN};
              
              location /.well-known/acme-challenge/ {
                  root /var/www/certbot;
              }
              
              location / {
                  return 301 https://\$host\$request_uri;
              }
          }

          # ConfiguraciÃ³n HTTPS principal
          server {
              listen 443 ssl http2;
              server_name ${FULL_DOMAIN};
              
              # Certificados SSL
              ssl_certificate /etc/letsencrypt/live/${FULL_DOMAIN}/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/${FULL_DOMAIN}/privkey.pem;
              
              # ConfiguraciÃ³n SSL moderna
              ssl_protocols TLSv1.2 TLSv1.3;
              ssl_ciphers HIGH:!aNULL:!MD5;
              ssl_prefer_server_ciphers on;
              
              # Headers de seguridad
              add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              
              location / {
                  proxy_pass http://localhost:5000;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto https;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection "upgrade";
              }
              
              # Excluir /test del proxy - servir directamente si existe
              location /test {
                  alias ${PROJECT_PATH}/test;
                  autoindex on;
                  try_files \$uri \$uri/ =404;
              }
              
              location /static {
                  alias ${PROJECT_PATH}/static;
                  expires 30d;
                  add_header Cache-Control "public, immutable";
              }
          }

          # RedirecciÃ³n www a no-www
          server {
              listen 443 ssl http2;
              server_name www.${FULL_DOMAIN};
              
              ssl_certificate /etc/letsencrypt/live/${FULL_DOMAIN}/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/${FULL_DOMAIN}/privkey.pem;
              
              return 301 https://${FULL_DOMAIN}\$request_uri;
          }
          NGINXCONF

          # Si no existe certificado SSL, crear configuraciÃ³n temporal HTTP
          if ! sudo test -f "/etc/letsencrypt/live/${FULL_DOMAIN}/fullchain.pem"; then
            echo "âš ï¸ Certificado SSL no encontrado, configurando HTTP temporal..."
            
            cat > /tmp/nginx-config << NGINXHTTPCONF
          server {
              listen 80;
              server_name ${FULL_DOMAIN} www.${FULL_DOMAIN};
              
              location /.well-known/acme-challenge/ {
                  root /var/www/certbot;
              }
              
              location / {
                  proxy_pass http://localhost:5000;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
              }
              
              location /test {
                  alias ${PROJECT_PATH}/test;
                  autoindex on;
              }
          }
          NGINXHTTPCONF
          fi

          # Aplicar configuraciÃ³n
          sudo mv /tmp/nginx-config /etc/nginx/sites-available/location-tracker
          sudo ln -sf /etc/nginx/sites-available/location-tracker /etc/nginx/sites-enabled/

          if sudo nginx -t; then
            sudo systemctl reload nginx
            echo "âœ… Nginx configurado correctamente"
          else
            echo "âŒ Error en configuraciÃ³n de Nginx"
            exit 1
          fi

      - name: ðŸš€ Deploy/Restart application with PM2
        run: |
          cd ${PROJECT_PATH}

          echo "ðŸš€ Gestionando aplicaciÃ³n con PM2..."

          # Limpiar aplicaciones antiguas con nombres numÃ©ricos
          pm2 list | grep -E "flask-app-[0-9]+" | awk '{print $2}' | while read old_app; do
            if [ "$old_app" != "${APP_NAME}" ]; then
              echo "Limpiando aplicaciÃ³n antigua: $old_app"
              pm2 delete "$old_app" 2>/dev/null || true
            fi
          done

          # Verificar si la aplicaciÃ³n ya existe
          if pm2 list | grep -q "${APP_NAME}"; then
            if [ "${CODE_UPDATED}" = "true" ]; then
              echo "ðŸ”„ CÃ³digo actualizado, recargando ${APP_NAME}..."
              pm2 reload ${APP_NAME} --update-env
              echo "âœ… AplicaciÃ³n recargada con los nuevos cambios"
            else
              echo "â„¹ï¸ Verificando estado de ${APP_NAME}..."
              
              # Reiniciar si estÃ¡ detenida o con error
              if pm2 list | grep "${APP_NAME}" | grep -E "(stopped|errored)"; then
                echo "âš ï¸ AplicaciÃ³n detenida o con error, reiniciando..."
                pm2 restart ${APP_NAME}
              else
                echo "âœ… AplicaciÃ³n ejecutÃ¡ndose correctamente"
              fi
            fi
          else
            echo "ðŸ†• Iniciando nueva aplicaciÃ³n ${APP_NAME}..."
            
            # Asegurar que el puerto 5000 estÃ© libre
            sudo fuser -k 5000/tcp 2>/dev/null || true
            sleep 2
            
            pm2 start start_app.sh \
              --name ${APP_NAME} \
              --interpreter bash \
              --cwd ${PROJECT_PATH} \
              --log-date-format "YYYY-MM-DD HH:mm:ss" \
              --max-restarts 3 \
              --restart-delay 3000
          fi

          # Guardar configuraciÃ³n de PM2
          pm2 save

          # Esperar a que la aplicaciÃ³n estÃ© lista
          sleep 5

      - name: ðŸ§ª Verify deployment
        run: |
          echo "ðŸ§ª Verificando despliegue..."

          # Verificar estado de PM2
          echo "ðŸ“Š Estado de PM2:"
          pm2 status ${APP_NAME}

          # Test Flask local
          MAX_RETRIES=5
          RETRY=0
          while [ $RETRY -lt $MAX_RETRIES ]; do
            if curl -s -f http://localhost:5000/ > /dev/null 2>&1; then
              echo "âœ… Flask respondiendo en puerto 5000"
              break
            else
              RETRY=$((RETRY + 1))
              if [ $RETRY -lt $MAX_RETRIES ]; then
                echo "â³ Esperando a Flask (intento $RETRY/$MAX_RETRIES)..."
                sleep 2
              else
                echo "âš ï¸ Flask no responde despuÃ©s de $MAX_RETRIES intentos"
              fi
            fi
          done

          # Verificar que /test estÃ¡ preservado
          if [ -d "${PROJECT_PATH}/test" ]; then
            echo "âœ… Directorio /test preservado correctamente"
            echo "   Contenido:"
            ls -la ${PROJECT_PATH}/test 2>/dev/null | head -5 || echo "   (vacÃ­o o sin acceso)"
          fi

          # Mostrar resumen
          echo ""
          echo "========================================="
          echo "ðŸŽ‰ DESPLIEGUE COMPLETADO"
          echo "========================================="
          echo "ðŸ“Š CONFIGURACIÃ“N:"
          echo "   - Runner: ${{ matrix.runner }}"
          echo "   - AplicaciÃ³n: ${APP_NAME}"
          echo "   - Dominio: ${FULL_DOMAIN}"
          echo "   - Proyecto: ${PROJECT_PATH}"
          echo "   - /test preservado: âœ…"
          echo ""
          echo "ðŸ”— URLs:"
          if sudo test -f "/etc/letsencrypt/live/${FULL_DOMAIN}/fullchain.pem"; then
            echo "   - https://${FULL_DOMAIN} (Principal)"
            echo "   - https://${FULL_DOMAIN}/test (Preservado)"
          else
            echo "   - http://${FULL_DOMAIN} (Principal)"
            echo "   - http://${FULL_DOMAIN}/test (Preservado)"
          fi
          echo "========================================="

      - name: ðŸ“„ Show logs on failure
        if: failure()
        run: |
          echo "âŒ Despliegue fallÃ³. Mostrando logs..."
          pm2 logs ${APP_NAME} --lines 50 --nostream || true
          sudo journalctl -u nginx -n 50 || true

      - name: ðŸ§¹ Cleanup
        if: always()
        run: |
          # Limpiar archivos temporales
          rm -f /tmp/temp_env_${{ matrix.instance }} 2>/dev/null || true
          rm -f /tmp/nginx-config 2>/dev/null || true
