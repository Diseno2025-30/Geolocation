name: Deploy Main to Self-Hosted Runners

on:
  push:
    branches: [main]
    paths:
      - "Proyecto_1_Diseno/**"
      - ".github/workflows/deploy-main.yml"
      - "!Proyecto_1_Diseno/test/**"
  workflow_dispatch: # Permite ejecutar manualmente

jobs:
  deploy-main:
    name: Deploy Main to Instance ${{ matrix.instance }}
    runs-on: 
      - self-hosted
      - EC2
      - ${{ matrix.runner-tag }}
    
    strategy:
      matrix:
        instance: [1, 2, 3, 4]
        include:
          - instance: 1
            runner-tag: "oliver-main"
            person: "Oliver"
          - instance: 2
            runner-tag: "hernando-main" 
            person: "Hernando"
          - instance: 3
            runner-tag: "alan-main"
            person: "Alan"
          - instance: 4
            runner-tag: "sebastian-main"
            person: "Sebastian"
    
    steps:
    - name: Verify EC2 instance
      run: |
        echo "üîç Verificando instancia EC2..."
        INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id || echo "No disponible")
        HOSTNAME=$(hostname)
        echo "üìç Instance ID: $INSTANCE_ID"
        echo "üìç Hostname: $HOSTNAME"
        echo "‚úÖ Ejecutando en modo SELF-HOSTED"
    
    - name: Determine configuration
      id: config
      run: |
        # Configuraci√≥n de la instancia desde matrix
        INSTANCE_NUM="${{ matrix.instance }}"
        PERSON_NAME="${{ matrix.person }}"
        
        echo "TARGET_INSTANCE=${INSTANCE_NUM}" >> $GITHUB_OUTPUT
        echo "PERSON_NAME=${PERSON_NAME}" >> $GITHUB_OUTPUT
        
        echo "üè† SELF-HOSTED: Desplegando main en instancia ${INSTANCE_NUM} (${PERSON_NAME})"

    - name: Checkout main branch
      uses: actions/checkout@v3
      with:
        ref: main
        fetch-depth: 0

    - name: Deploy main to local instance
      env:
        ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', matrix.instance)] }}
        DOMAIN_BASE: tumaquinaya.com
        PERSON_NAME: ${{ matrix.person }}
        INSTANCE_NUM: ${{ matrix.instance }}
      run: |
        echo "üöÄ SELF-HOSTED: Desplegando main en instancia ${INSTANCE_NUM}"
        
        # Crear archivo .env directamente
        echo "$ENV_FILE" > /tmp/main_env_file
        
        # Extraer NAME del .env
        NAME_VALUE=$(grep "^NAME=" /tmp/main_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | xargs)
        NAME_LOWER=$(echo "$NAME_VALUE" | tr '[:upper:]' '[:lower:]')
        PERSON_LOWER=$(echo "$PERSON_NAME" | tr '[:upper:]' '[:lower:]')
        
        if [ "${NAME_LOWER}" != "${PERSON_LOWER}" ]; then
            echo "‚ö† ADVERTENCIA: El NAME en .env (${NAME_VALUE}) no coincide con ${PERSON_NAME}"
        fi
        
        FULL_DOMAIN="${NAME_LOWER}.${DOMAIN_BASE}"
        
        echo "üìã Configuraci√≥n:"
        echo "   - Rama: main"
        echo "   - Persona: ${PERSON_NAME}"
        echo "   - Instancia: ${INSTANCE_NUM}"
        echo "   - Dominio: ${FULL_DOMAIN}"
        echo "   - Modo: SELF-HOSTED (main production)"
        
        # Crear script de despliegue local para main
        cat > /tmp/deploy_main_local.sh << 'DEPLOYEOF'
        #!/bin/bash
        set -e
        
        SUBDOMAIN="${1}"
        DOMAIN_BASE="${2}"
        INSTANCE_NUM="${3}"
        PERSON_NAME="${4}"
        
        echo "üîß Configuraci√≥n de despliegue main (SELF-HOSTED):"
        echo "   - Rama: main"
        echo "   - Persona: ${PERSON_NAME}"
        echo "   - Subdominio: ${SUBDOMAIN}"
        echo "   - Dominio: ${SUBDOMAIN}.${DOMAIN_BASE}"
        echo "   - Instancia: ${INSTANCE_NUM}"
        
        BASE_DIR="/opt/location-tracker"
        MAIN_DIR="${BASE_DIR}/Proyecto_1_Diseno"
        mkdir -p "${MAIN_DIR}"
        cd "${MAIN_DIR}"
        
        echo "üìÅ Directorio principal: ${MAIN_DIR}"
        
        # Backup del directorio /test si existe
        TEST_BACKUP=""
        if [ -d "test" ]; then
          TEST_BACKUP="/tmp/test_backup_main_$$"
          echo "üíæ Respaldando directorio /test..."
          cp -r test "${TEST_BACKUP}" 2>/dev/null || true
        fi
        
        if [ -d .git ]; then
          echo "üì¶ Actualizando c√≥digo de la rama main..."
          git fetch origin main
          git checkout main
          git reset --hard origin/main
          CODE_UPDATED=true
        else
          echo "üì• Clonando repositorio en rama main..."
          cd "$(dirname "${MAIN_DIR}")"
          git clone -b main https://github.com/Diseno2025-30/Geolocation.git .
          CODE_UPDATED=true
        fi
        
        cd "${MAIN_DIR}"
        
        # Restaurar directorio /test si exist√≠a
        if [ -n "${TEST_BACKUP}" ] && [ -d "${TEST_BACKUP}" ]; then
          echo "üîÑ Restaurando directorio /test..."
          rm -rf test 2>/dev/null || true
          mv "${TEST_BACKUP}" test
          echo "‚úÖ Directorio /test preservado"
        fi
        
        PROJECT_PATH=$(pwd)
        
        # Copiar .env desde el backup temporal
        if [ -f "/tmp/main_env_file" ]; then
          cp "/tmp/main_env_file" .env
        fi
        
        echo "" >> .env
        echo "# Configuraci√≥n de producci√≥n main" >> .env
        echo "PRODUCTION_MODE=true" >> .env
        echo "PERSON_NAME=${PERSON_NAME}" >> .env
        
        FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
        APP_NAME="flask-app-${SUBDOMAIN}"
        MAIN_PORT=5000
        
        echo "üìä Configuraci√≥n:"
        echo "   - APP_NAME: ${APP_NAME}"
        echo "   - Puerto main: ${MAIN_PORT}"
        echo "   - Proyecto: ${PROJECT_PATH}"
        
        echo "üì¶ Instalando dependencias..."
        sudo apt-get update -qq
        sudo apt-get install -y python3-pip python3-venv nginx
        
        if ! command -v pm2 &> /dev/null; then
          if ! command -v node &> /dev/null; then
            curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
            sudo apt-get install -y nodejs
          fi
          sudo npm install -g pm2
          pm2 startup systemd -u ubuntu --hp /home/ubuntu
        fi
        
        echo "üêç Configurando entorno Python para producci√≥n..."
        if [ ! -d "venv" ]; then
          python3 -m venv venv
        fi
        
        source venv/bin/activate
        pip install --upgrade pip
        pip install flask psycopg2-binary python-dotenv
        
        if [ -f requirements.txt ]; then
          pip install -r requirements.txt
        fi
        
        # Limpiar apps antiguas con nombres legacy
        pm2 stop "flask-app-${INSTANCE_NUM}" 2>/dev/null || true
        pm2 delete "flask-app-${INSTANCE_NUM}" 2>/dev/null || true
        
        # Parar la aplicaci√≥n actual si existe
        if pm2 list | grep -q "${APP_NAME}"; then
          echo "üîÑ Recargando ${APP_NAME}..."
          pm2 stop ${APP_NAME}
        fi
        
        sudo fuser -k ${MAIN_PORT}/tcp 2>/dev/null || true
        sleep 2
        
        cat > start_main_app.sh << STARTSCRIPT
        #!/bin/bash
        cd "\$(dirname "\$0")"
        source venv/bin/activate
        export FLASK_APP=udp_flask_server.py
        export FLASK_ENV=production
        export FLASK_TRUSTED_PROXIES="127.0.0.1"
        python udp_flask_server.py
        STARTSCRIPT
        chmod +x start_main_app.sh
        
        echo "üöÄ Iniciando aplicaci√≥n de producci√≥n..."
        if pm2 list | grep -q "${APP_NAME}"; then
          pm2 reload ${APP_NAME} --update-env
        else
          pm2 start start_main_app.sh \
            --name ${APP_NAME} \
            --interpreter bash \
            --cwd ${PROJECT_PATH} \
            --log-date-format "YYYY-MM-DD HH:mm:ss"
        fi
        
        pm2 save
        
        echo "‚è≥ Esperando inicio de la aplicaci√≥n..."
        sleep 5
        
        echo "üìä Estado de la aplicaci√≥n:"
        pm2 status ${APP_NAME}
        
        echo "üß™ Probando aplicaci√≥n..."
        if curl -s -f http://localhost:${MAIN_PORT}/ > /dev/null 2>&1; then
          echo "‚úÖ Aplicaci√≥n respondiendo en puerto ${MAIN_PORT}"
        else
          echo "‚ö† La aplicaci√≥n no responde"
          pm2 logs ${APP_NAME} --lines 20 --nostream
        fi
        
        echo ""
        echo "========================================="
        echo "üéâ PRODUCCI√ìN DESPLEGADA (SELF-HOSTED)"
        echo "========================================="
        echo ""
        echo "üìä INFORMACI√ìN:"
        echo "   - Persona: ${PERSON_NAME}"
        echo "   - Rama: main"
        echo "   - Instancia EC2: ${INSTANCE_NUM}"
        echo "   - Aplicaci√≥n PM2: ${APP_NAME}"
        echo "   - Puerto interno: ${MAIN_PORT}"
        echo "   - Modo: LOCAL (sin SSH)"
        echo ""
        echo "üîó URLS:"
        echo "   - Producci√≥n: https://${FULL_DOMAIN}/"
        if [ -d "${PROJECT_PATH}/test" ]; then
        echo "   - Test: https://${FULL_DOMAIN}/test (preservado)"
        fi
        echo ""
        echo "üìç ENDPOINTS PRINCIPALES:"
        echo "   - https://${FULL_DOMAIN}/coordenadas"
        echo "   - https://${FULL_DOMAIN}/database"
        echo "   - https://${FULL_DOMAIN}/version"
        echo "   - https://${FULL_DOMAIN}/health"
        echo ""
        echo "üõ† COMANDOS √öTILES:"
        echo "   - Ver logs prod: pm2 logs ${APP_NAME}"
        echo "   - Reiniciar prod: pm2 restart ${APP_NAME}"
        if [ -d "${PROJECT_PATH}/test" ]; then
        echo "   - Ver logs test: pm2 logs flask-test-${SUBDOMAIN}"
        echo "   - Reiniciar test: pm2 restart flask-test-${SUBDOMAIN}"
        fi
        echo "   - Estado: pm2 status"
        echo "========================================="
        DEPLOYEOF
        
        chmod +x /tmp/deploy_main_local.sh
        
        # Ejecutar localmente (sin SSH)
        /tmp/deploy_main_local.sh "${NAME_LOWER}" "${DOMAIN_BASE}" "${INSTANCE_NUM}" "${PERSON_NAME}"
        
        # Mover el archivo .env a su ubicaci√≥n final
        if [ -f /tmp/main_env_file ]; then
          mv /tmp/main_env_file /opt/location-tracker/Proyecto_1_Diseno/.env
        fi
        
        # Limpiar
        rm -f /tmp/deploy_main_local.sh
        
        echo "‚úÖ Despliegue SELF-HOSTED completado para ${PERSON_NAME}"

    - name: Verify deployment
      run: |
        echo "‚úÖ Deployment completed for ${{ matrix.person }}"
        echo "   - Instance: ${{ matrix.instance }}"
        echo "   - App: flask-app-$(echo "${{ matrix.person }}" | tr '[:upper:]' '[:lower:]')"
        
        # Verificar si el directorio test se preserv√≥
        if [ -d "/opt/location-tracker/Proyecto_1_Diseno/test" ]; then
          echo "‚úÖ /test directory preserved"
        fi

  summary:
    runs-on: ubuntu-latest  # Usar GitHub runner para el resumen
    needs: deploy-main
    if: always()  # Ejecutar siempre, incluso si alg√∫n deployment falla
    steps:
      - name: üìä Deployment Summary
        run: |
          echo "========================================="
          echo "üéâ MAIN DEPLOYMENT SUMMARY"
          echo "========================================="
          echo ""
          echo "üìä STATUS:"
          echo "   Oliver (Instance 1): ${{ needs.deploy-main.result }}"
          echo "   Hernando (Instance 2): ${{ needs.deploy-main.result }}"
          echo "   Alan (Instance 3): ${{ needs.deploy-main.result }}"
          echo "   Sebastian (Instance 4): ${{ needs.deploy-main.result }}"
          echo ""
          echo "üîó PRODUCTION URLS:"
          echo "   - https://oliver.tumaquinaya.com"
          echo "   - https://hernando.tumaquinaya.com"
          echo "   - https://alan.tumaquinaya.com"
          echo "   - https://sebastian.tumaquinaya.com"
          echo ""
          echo "üìÅ TEST ENDPOINTS (preserved if they existed):"
          echo "   - https://oliver.tumaquinaya.com/test"
          echo "   - https://hernando.tumaquinaya.com/test"
          echo "   - https://alan.tumaquinaya.com/test"
          echo "   - https://sebastian.tumaquinaya.com/test"
          echo ""
          echo "üöÄ Deployment completed at: $(date)"
          echo "========================================="