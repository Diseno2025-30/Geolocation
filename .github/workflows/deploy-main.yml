name: Deploy Flask App to 4 EC2 Instances

on:
  push:
    branches: [main]
    paths:
      # Se activa si hay cambios en el proyecto o el propio workflow
      - "Proyecto_1_Diseno/**"
      - ".github/workflows/deploy-main.yml"
      - ".github/scripts/**"

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false # Si un despliegue falla, los otros continuar√°n.
      matrix:
        # Define las 4 instancias en las que se desplegar√°
        instance: [1, 2, 3, 4]

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Deploy to EC2 Instance ${{ matrix.instance }}
        env:
          # Selecciona los secretos de GitHub din√°micamente para cada instancia
          HOST: ${{ secrets[format('EC2_HOST_{0}', matrix.instance)] }}
          USER: ${{ secrets[format('EC2_USER_{0}', matrix.instance)] }}
          KEY: ${{ secrets[format('EC2_SSH_KEY_{0}', matrix.instance)] }}
          FIREBASE_SDK: ${{ secrets.FIREBASE_SDK_JSON }}
          ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', matrix.instance)] }}
          DOMAIN_BASE: tumaquinaya.com
        run: |
          echo "üöÄ Iniciando despliegue en la instancia ${{ matrix.instance }}..."

          # Crear el archivo de llave SSH temporalmente
          echo "$KEY" > deploy_key
          chmod 600 deploy_key

          # Crear archivo .env temporal
          echo "$ENV_FILE" > temp_env_file

          echo "$FIREBASE_SDK" > temp_sdk.json

          # Extraer el NAME del archivo .env para usarlo como subdominio
          NAME_VALUE=$(grep "^NAME=" temp_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | tr '[:upper:]' '[:lower:]' | xargs)

          if [ -z "$NAME_VALUE" ]; then
              echo "‚ö†Ô∏è No se encontr√≥ NAME en .env, usando instance-${{ matrix.instance }}"
              NAME_VALUE="instance-${{ matrix.instance }}"
          fi

          location /static/ {
              alias ${PROJECT_PATH}/static/;
              add_header Cache-Control "no-cache, no-store, must-revalidate";
              add_header Pragma "no-cache";
              add_header Expires "0";
          }

          # Construir el dominio completo
          FULL_DOMAIN="${NAME_VALUE}.${DOMAIN_BASE}"

          echo "üìã Configuraci√≥n detectada:"
          echo "   - NAME (subdominio): ${NAME_VALUE}"
          echo "   - Dominio completo: ${FULL_DOMAIN}"
          echo "   - IP del servidor: ${HOST}"

          # Copiar scripts desde el repositorio
          cp .github/scripts/setup_osrm.sh .
          cp .github/scripts/deploy_remote.sh .

          # Transferir archivos al servidor
          echo "üì§ Transfiriendo archivos al servidor..."

          # Determinar la ruta del proyecto
          PROJECT_PATH=$(ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} '
            if [ -d "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno" ]; then
              echo "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno"
            else
              echo "/opt/location-tracker/Proyecto_1_Diseno"
            fi
          ')

          echo "Asegurando que el directorio ${PROJECT_PATH} exista y tenga permisos..."
          ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} " \
            sudo mkdir -p ${PROJECT_PATH} && \
            sudo chown -R ${USER}:${USER} ${PROJECT_PATH} \
          "

          # Transferir .env
          scp -o StrictHostKeyChecking=no -i deploy_key temp_env_file ${USER}@${HOST}:${PROJECT_PATH}/.env
          scp -o StrictHostKeyChecking=no -i deploy_key temp_sdk.json ${USER}@${HOST}:${PROJECT_PATH}/firebase-admin-sdk.json

          # Transferir scripts
          scp -o StrictHostKeyChecking=no -i deploy_key setup_osrm.sh ${USER}@${HOST}:/tmp/
          scp -o StrictHostKeyChecking=no -i deploy_key deploy_remote.sh ${USER}@${HOST}:/tmp/deploy_remote.sh

          echo "üöÄ Ejecutando despliegue con SSL y OSRM..."

          # Ejecutar setup de OSRM primero
          ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} \
            "chmod +x /tmp/setup_osrm.sh && /tmp/setup_osrm.sh"

          # Ejecutar despliegue de la aplicaci√≥n
          ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} \
            "chmod +x /tmp/deploy_remote.sh && \
             /tmp/deploy_remote.sh '${NAME_VALUE}' '${DOMAIN_BASE}' '${{ matrix.instance }}' && \
             rm /tmp/deploy_remote.sh /tmp/setup_osrm.sh"

          # Limpiar archivos temporales
          rm -f deploy_key temp_env_file deploy_remote.sh setup_osrm.sh

          echo "‚úÖ Despliegue con SSL/HTTPS completado para instancia ${{ matrix.instance }}"
