name: Deploy Flask App with Branch Testing

on:
  push:
    branches: 
      - main
      - oliver-branch
      - alan-branch
      - sebastian-branch
      - hernando-branch
    paths:
      - 'Proyecto_1_Diseno/**'
      - '.github/workflows/deploy.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - instance: 1
            name: oliver
            branch: oliver-branch
          - instance: 2
            name: alan
            branch: alan-branch
          - instance: 3
            name: sebastian
            branch: sebastian-branch
          - instance: 4
            name: hernando
            branch: hernando-branch

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Determine deployment type
        id: deployment
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          echo "Current branch: $BRANCH_NAME"
          echo "Person branch: ${{ matrix.branch }}"
          
          if [ "$BRANCH_NAME" = "main" ]; then
            echo "DEPLOY_MAIN=true" >> $GITHUB_OUTPUT
            echo "DEPLOY_TEST=false" >> $GITHUB_OUTPUT
            echo "📦 Deploying MAIN to all instances"
          elif [ "$BRANCH_NAME" = "${{ matrix.branch }}" ]; then
            echo "DEPLOY_MAIN=false" >> $GITHUB_OUTPUT
            echo "DEPLOY_TEST=true" >> $GITHUB_OUTPUT
            echo "🧪 Deploying TEST for ${{ matrix.name }}"
          else
            echo "DEPLOY_MAIN=false" >> $GITHUB_OUTPUT
            echo "DEPLOY_TEST=false" >> $GITHUB_OUTPUT
            echo "⏭️ Skipping deployment for this instance"
          fi

      - name: Deploy to EC2 Instance ${{ matrix.instance }}
        if: steps.deployment.outputs.DEPLOY_MAIN == 'true' || steps.deployment.outputs.DEPLOY_TEST == 'true'
        env:
          HOST: ${{ secrets[format('EC2_HOST_{0}', matrix.instance)] }}
          USER: ${{ secrets[format('EC2_USER_{0}', matrix.instance)] }}
          KEY: ${{ secrets[format('EC2_SSH_KEY_{0}', matrix.instance)] }}
          ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', matrix.instance)] }}
          DOMAIN_BASE: tumaquinaya.com
          DEPLOY_MAIN: ${{ steps.deployment.outputs.DEPLOY_MAIN }}
          DEPLOY_TEST: ${{ steps.deployment.outputs.DEPLOY_TEST }}
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          echo "🚀 Iniciando despliegue en la instancia ${{ matrix.instance }} (${{ matrix.name }})..."
          
          # Crear el archivo de llave SSH temporalmente
          echo "$KEY" > deploy_key
          chmod 600 deploy_key
          
          # Crear archivo .env temporal
          echo "$ENV_FILE" > temp_env_file
          
          # Extraer el NAME del archivo .env
          NAME_VALUE=$(grep "^NAME=" temp_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | tr '[:upper:]' '[:lower:]' | xargs)
          
          if [ -z "$NAME_VALUE" ]; then
            NAME_VALUE="${{ matrix.name }}"
          fi
          
          FULL_DOMAIN="${NAME_VALUE}.${DOMAIN_BASE}"
          
          echo "📋 Configuración detectada:"
          echo " - NAME (subdominio): ${NAME_VALUE}"
          echo " - Dominio completo: ${FULL_DOMAIN}"
          echo " - Deploy Main: ${DEPLOY_MAIN}"
          echo " - Deploy Test: ${DEPLOY_TEST}"
          echo " - Branch: ${BRANCH_NAME}"
          
          # Crear script de despliegue remoto
          cat > deploy_remote.sh << 'DEPLOYEOF'
          #!/bin/bash
          set -e
          
          # Recibir parámetros
          SUBDOMAIN="${1}"
          DOMAIN_BASE="${2}"
          INSTANCE_NUM="${3}"
          DEPLOY_MAIN="${4}"
          DEPLOY_TEST="${5}"
          BRANCH_NAME="${6}"
          
          echo "🔧 Configuración recibida:"
          echo " - Subdominio: ${SUBDOMAIN}"
          echo " - Dominio base: ${DOMAIN_BASE}"
          echo " - Instancia: ${INSTANCE_NUM}"
          echo " - Deploy Main: ${DEPLOY_MAIN}"
          echo " - Deploy Test: ${DEPLOY_TEST}"
          echo " - Branch: ${BRANCH_NAME}"
          
          # Crear directorio base
          BASE_DIR="/opt/location-tracker"
          sudo mkdir -p ${BASE_DIR}
          sudo chown $USER:$USER ${BASE_DIR}
          cd ${BASE_DIR}
          
          # Función para configurar una aplicación Flask
          setup_flask_app() {
              local APP_PATH=$1
              local APP_NAME=$2
              local PORT=$3
              local IS_TEST=$4
              
              echo "🔧 Configurando aplicación: ${APP_NAME} en puerto ${PORT}"
              
              cd ${APP_PATH}
              
              # Crear entorno virtual si no existe
              if [ ! -d "venv" ]; then
                  python3 -m venv venv
              fi
              
              source venv/bin/activate
              pip install --upgrade pip
              pip install flask psycopg2-binary python-dotenv
              
              if [ -f requirements.txt ]; then
                  pip install -r requirements.txt
              fi
              
              # Crear script de inicio modificado para el puerto específico
              cat > start_app_${PORT}.sh << STARTSCRIPT
          #!/bin/bash
          SCRIPT_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
          cd "\$SCRIPT_DIR"
          source venv/bin/activate
          export FLASK_APP=udp_flask_server.py
          export FLASK_ENV=production
          export FLASK_PORT=${PORT}
          export IS_TEST_DEPLOYMENT="${IS_TEST}"
          python -c "
          import sys
          sys.path.insert(0, '.')
          from udp_flask_server import app
          app.run(host='0.0.0.0', port=${PORT})
          "
          STARTSCRIPT
              chmod +x start_app_${PORT}.sh
              
              # Gestionar con PM2
              if pm2 list | grep -q "${APP_NAME}"; then
                  echo "🔄 Recargando ${APP_NAME}..."
                  pm2 reload ${APP_NAME} --update-env
              else
                  echo "🆕 Iniciando ${APP_NAME}..."
                  pm2 start start_app_${PORT}.sh \
                      --name ${APP_NAME} \
                      --interpreter bash \
                      --cwd ${APP_PATH} \
                      --max-restarts 3
              fi
          }
          
          # DESPLIEGUE PRINCIPAL (puerto 5000)
          if [ "${DEPLOY_MAIN}" = "true" ]; then
              echo "📦 Desplegando versión MAIN..."
              
              # Clonar o actualizar main
              MAIN_DIR="${BASE_DIR}/main"
              if [ ! -d "${MAIN_DIR}" ]; then
                  git clone https://github.com/Diseno2025-30/Geolocation.git ${MAIN_DIR}
              fi
              
              cd ${MAIN_DIR}
              git fetch origin main
              git checkout main
              git reset --hard origin/main
              
              cd Proyecto_1_Diseno
              
              # Copiar el .env
              cp /tmp/.env .
              
              # Configurar aplicación principal
              setup_flask_app "$(pwd)" "flask-app-${SUBDOMAIN}" "5000" "false"
          fi
          
          # DESPLIEGUE DE TEST (puerto 5001)
          if [ "${DEPLOY_TEST}" = "true" ]; then
              echo "🧪 Desplegando versión TEST desde branch ${BRANCH_NAME}..."
              
              # Clonar o actualizar branch personal
              TEST_DIR="${BASE_DIR}/test-${SUBDOMAIN}"
              if [ ! -d "${TEST_DIR}" ]; then
                  git clone https://github.com/Diseno2025-30/Geolocation.git ${TEST_DIR}
              fi
              
              cd ${TEST_DIR}
              git fetch origin ${BRANCH_NAME}
              git checkout ${BRANCH_NAME}
              git reset --hard origin/${BRANCH_NAME}
              
              cd Proyecto_1_Diseno
              
              # Copiar el .env
              cp /tmp/.env .
              
              # Configurar aplicación de test
              setup_flask_app "$(pwd)" "flask-test-${SUBDOMAIN}" "5001" "true"
          fi
          
          # Configurar Nginx
          echo "🌐 Configurando Nginx..."
          
          # Instalar Nginx si no está instalado
          if ! command -v nginx &> /dev/null; then
              sudo apt-get update
              sudo apt-get install -y nginx certbot python3-certbot-nginx
          fi
          
          FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
          
          # Crear configuración de Nginx
          cat > /tmp/nginx-config << NGINXCONF
          server {
              listen 80;
              server_name ${FULL_DOMAIN} www.${FULL_DOMAIN};
              
              # Ruta principal - siempre apunta a main (puerto 5000)
              location / {
                  proxy_pass http://localhost:5000;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
              }
              
              # Ruta de test - apunta al branch personal (puerto 5001)
              location /test {
                  # Solo disponible si hay una app de test corriendo
                  proxy_pass http://localhost:5001;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  
                  # Si no hay app de test, mostrar página de error
                  proxy_intercept_errors on;
                  error_page 502 503 504 /test_unavailable.html;
              }
              
              # Página de error para cuando /test no está disponible
              location = /test_unavailable.html {
                  internal;
                  default_type text/html;
                  return 200 '<html><body><h1>Test Environment Not Available</h1><p>No test deployment is currently active for this instance.</p><p><a href="/">Return to main site</a></p></body></html>';
              }
              
              # Archivos estáticos para main
              location /static {
                  alias ${BASE_DIR}/main/Proyecto_1_Diseno/static;
                  expires 30d;
              }
              
              # Archivos estáticos para test
              location /test/static {
                  alias ${BASE_DIR}/test-${SUBDOMAIN}/Proyecto_1_Diseno/static;
                  expires 30d;
              }
          }
          NGINXCONF
          
          sudo mv /tmp/nginx-config /etc/nginx/sites-available/location-tracker-${SUBDOMAIN}
          sudo ln -sf /etc/nginx/sites-available/location-tracker-${SUBDOMAIN} /etc/nginx/sites-enabled/
          
          if sudo nginx -t; then
              sudo systemctl reload nginx
              echo "✅ Nginx configurado correctamente"
          else
              echo "❌ Error en configuración de Nginx"
              exit 1
          fi
          
          # Guardar configuración de PM2
          pm2 save
          
          # Resumen final
          echo ""
          echo "========================================="
          echo "🎉 DESPLIEGUE COMPLETADO"
          echo "========================================="
          echo ""
          echo "📊 CONFIGURACIÓN:"
          echo " - Dominio: ${FULL_DOMAIN}"
          echo " - Main desplegado: ${DEPLOY_MAIN}"
          echo " - Test desplegado: ${DEPLOY_TEST}"
          echo ""
          echo "🔗 ACCESO:"
          echo " - Producción: http://${FULL_DOMAIN}/"
          if [ "${DEPLOY_TEST}" = "true" ]; then
              echo " - Test: http://${FULL_DOMAIN}/test"
          fi
          echo ""
          echo "📊 Aplicaciones PM2 activas:"
          pm2 list
          echo "========================================="
          
          DEPLOYEOF
          
          # Transferir archivos al servidor
          echo "📤 Transfiriendo archivos al servidor..."
          
          # Transferir .env
          scp -o StrictHostKeyChecking=no -i deploy_key temp_env_file ${USER}@${HOST}:/tmp/.env
          
          # Transferir y ejecutar script
          scp -o StrictHostKeyChecking=no -i deploy_key deploy_remote.sh ${USER}@${HOST}:/tmp/deploy_remote.sh
          
          ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} \
              "chmod +x /tmp/deploy_remote.sh && \
               /tmp/deploy_remote.sh '${NAME_VALUE}' '${DOMAIN_BASE}' '${{ matrix.instance }}' '${DEPLOY_MAIN}' '${DEPLOY_TEST}' '${BRANCH_NAME}' && \
               rm /tmp/deploy_remote.sh /tmp/.env"
          
          # Limpiar archivos temporales
          rm -f deploy_key temp_env_file deploy_remote.sh
          
          echo "✅ Despliegue completado para instancia ${{ matrix.instance