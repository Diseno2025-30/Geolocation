name: Deploy Flask App to 4 EC2 Instances

on:
  push:
    branches: [ main ]
    paths:
      # Se activa si hay cambios en el proyecto o el propio workflow
      - 'Proyecto_1_Diseno/**'
      - '.github/workflows/deploy.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false # Si un despliegue falla, los otros continuar√°n.
      matrix:
        # Define las 4 instancias
        instance: [1, 2, 3, 4]

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Deploy to EC2 Instance ${{ matrix.instance }}
      env:
        # Selecciona los secretos de GitHub din√°micamente para cada instancia
        HOST: ${{ secrets[format('EC2_HOST_{0}', matrix.instance)] }}
        USER: ${{ secrets[format('EC2_USER_{0}', matrix.instance)] }}
        KEY: ${{ secrets[format('EC2_SSH_KEY_{0}', matrix.instance)] }}
        ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', matrix.instance)] }}
        DOMAIN_BASE: tumaquinaya.com
      run: |
        echo "üöÄ Iniciando despliegue en la instancia ${{ matrix.instance }}..."
        
        # Crear el archivo de llave SSH temporalmente
        echo "$KEY" > deploy_key
        chmod 600 deploy_key
        
        # Crear archivo .env temporal
        echo "$ENV_FILE" > temp_env_file
        
        # Extraer el NAME del archivo .env para usarlo como subdominio
        NAME_VALUE=$(grep "^NAME=" temp_env_file | cut -d'=' -f2 | tr '[:upper:]' '[:lower:]')
        
        if [ -z "$NAME_VALUE" ]; then
            echo "‚ùå Error: No se encontr√≥ la variable NAME en el archivo .env"
            exit 1
        fi
        
        # Construir el dominio completo
        FULL_DOMAIN="${NAME_VALUE}.${DOMAIN_BASE}"
        
        echo "üìã Configuraci√≥n detectada:"
        echo "   - NAME (subdominio): ${NAME_VALUE}"
        echo "   - Dominio completo: ${FULL_DOMAIN}"
        echo "   - IP del servidor: ${HOST}"
        
        # Script de despliegue remoto v√≠a SSH - Primera parte: preparar proyecto
        ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} '
          # 0. Usar la ubicaci√≥n existente o crear nueva
          if [ -d "/home/ubuntu/Web-server-UDP" ]; then
            echo "üìÅ Usando proyecto existente en /home/ubuntu/Web-server-UDP"
            cd /home/ubuntu/Web-server-UDP
          else
            echo "üìÅ Creando nueva estructura en /opt/location-tracker"
            sudo mkdir -p /opt/location-tracker
            sudo chown $USER:$USER /opt/location-tracker
            cd /opt/location-tracker
          fi
          
          # 1. Actualizar el c√≥digo desde el repositorio
          echo "üì¶ Actualizando c√≥digo desde Git..."
          if [ -d .git ]; then
            git pull origin main
          else
            git clone https://github.com/${{ github.repository }}.git .
          fi
          
          # 2. Navegar al directorio del proyecto
          cd Proyecto_1_Diseno
        '
        
        # 3. Determinar la ruta correcta del proyecto
        echo "‚öôÔ∏è Determinando ruta del proyecto..."
        PROJECT_PATH=$(ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} '
          if [ -d "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno" ]; then
            echo "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno"
          else
            echo "/opt/location-tracker/Proyecto_1_Diseno"
          fi
        ')
        
        echo "üìÇ Ruta del proyecto: $PROJECT_PATH"
        
        # 4. Transferir archivo .env
        echo "üì§ Transfiriendo archivo .env..."
        scp -o StrictHostKeyChecking=no -i deploy_key temp_env_file ${USER}@${HOST}:${PROJECT_PATH}/.env
        
        # 5. Continuar con el despliegue - Segunda parte
        ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} << 'ENDSSH'
          # Variables base
          DOMAIN_BASE="tumaquinaya.com"
          HOST_IP="'${HOST}'"
          
          # Determinar ruta del proyecto
          if [ -d "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno" ]; then
            PROJECT_PATH="/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno"
          else
            PROJECT_PATH="/opt/location-tracker/Proyecto_1_Diseno"
          fi
          
          # Ir al directorio del proyecto
          cd $PROJECT_PATH
          
          # Leer las variables del archivo .env
          source .env
          
          # Convertir NAME a min√∫sculas para usar como subdominio
          SUBDOMAIN=$(echo "$NAME" | tr '[:upper:]' '[:lower:]')
          FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
          
          # Exportar variables para uso en la configuraci√≥n
          export SUBDOMAIN
          export FULL_DOMAIN
          export HOST_IP
          export PROJECT_PATH
          
          # Verificar que el .env se transfiri√≥ correctamente
          echo "üìã Verificando configuraci√≥n..."
          echo "Variables de entorno:"
          echo "  - NAME: ${NAME}"
          echo "  - SUBDOMAIN: ${SUBDOMAIN}"
          echo "  - DOMINIO COMPLETO: ${FULL_DOMAIN}"
          echo "  - DB_HOST: [CONFIGURADO]"
          echo "  - DB_NAME: [CONFIGURADO]"
          echo "  - DB_USER: [CONFIGURADO]"
          echo "  - DB_PASSWORD: [CONFIGURADO]"
          
          # Actualizar sistema e instalar Node.js si no est√° instalado
          echo "üì¶ Verificando Node.js y npm..."
          if ! command -v node &> /dev/null; then
            echo "Instalando Node.js..."
            curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
            sudo apt-get install -y nodejs
          fi
          
          # Instalar PM2 globalmente si no est√° instalado
          echo "‚ö° Verificando PM2..."
          if ! command -v pm2 &> /dev/null; then
            echo "Instalando PM2..."
            sudo npm install -g pm2
            pm2 startup systemd -u $USER --hp /home/$USER
          fi
          
          # Instalar dependencias de Python con virtual environment
          echo "üìã Configurando entorno virtual de Python..."
          sudo apt-get update
          sudo apt-get install -y python3-pip python3-venv nginx
          
          # Crear entorno virtual si no existe
          if [ ! -d "venv" ]; then
            python3 -m venv venv
          fi
          
          # Activar entorno virtual e instalar dependencias
          source venv/bin/activate
          pip install flask psycopg2-binary python-dotenv
          
          # Si existe requirements.txt, instalarlo
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
          
          # Configurar Nginx como proxy reverso con el dominio correcto
          echo "üåê Configurando Nginx proxy reverso para ${FULL_DOMAIN}..."
          
          # Crear archivo de configuraci√≥n de Nginx
          cat > /tmp/nginx-config << NGINXEOF
          server {
              listen 80;
              server_name ${FULL_DOMAIN};
              
              # Configuraci√≥n de logs espec√≠ficos para este dominio
              access_log /var/log/nginx/${SUBDOMAIN}_access.log;
              error_log /var/log/nginx/${SUBDOMAIN}_error.log;
              
              # Configuraci√≥n del proxy
              location / {
                  proxy_pass http://localhost:5000;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  
                  # Timeouts
                  proxy_connect_timeout 60s;
                  proxy_send_timeout 60s;
                  proxy_read_timeout 60s;
                  
                  # Buffering
                  proxy_buffering off;
              }
              
              # Manejo de archivos est√°ticos (si los tienes)
              location /static {
                  alias ${PROJECT_PATH}/static;
                  expires 30d;
                  add_header Cache-Control "public, immutable";
              }
          }

          # Redirigir tr√°fico directo por IP al subdominio
          server {
              listen 80;
              server_name ${HOST_IP};
              return 301 http://${FULL_DOMAIN}\$request_uri;
          }

          # Configuraci√≥n adicional para www si es necesario
          server {
              listen 80;
              server_name www.${FULL_DOMAIN};
              return 301 http://${FULL_DOMAIN}\$request_uri;
          }

          # Configuraci√≥n por defecto para rechazar peticiones sin host v√°lido
          server {
              listen 80 default_server;
              server_name _;
              return 444;
          }
          NGINXEOF
          
          # Mover el archivo de configuraci√≥n a su ubicaci√≥n final
          sudo mv /tmp/nginx-config /etc/nginx/sites-available/location-tracker
          
          # Habilitar el sitio de Nginx
          sudo ln -sf /etc/nginx/sites-available/location-tracker /etc/nginx/sites-enabled/
          
          # Eliminar configuraci√≥n por defecto si existe
          sudo rm -f /etc/nginx/sites-enabled/default
          
          # Verificar y reiniciar Nginx
          echo "üîç Verificando configuraci√≥n de Nginx..."
          sudo nginx -t
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Configuraci√≥n de Nginx v√°lida"
            sudo systemctl restart nginx
            sudo systemctl enable nginx
          else
            echo "‚ùå Error en la configuraci√≥n de Nginx"
            echo "Mostrando configuraci√≥n para depuraci√≥n:"
            sudo cat /etc/nginx/sites-available/location-tracker
            exit 1
          fi
          
          # Detener aplicaci√≥n anterior si existe
          echo "üõë Deteniendo aplicaci√≥n anterior..."
          pm2 stop flask-app-${SUBDOMAIN} 2>/dev/null || echo "No hay aplicaci√≥n anterior corriendo"
          pm2 delete flask-app-${SUBDOMAIN} 2>/dev/null || echo "No hay aplicaci√≥n anterior que eliminar"
          
          # Crear script de inicio para PM2
          echo "üìù Creando script de inicio..."
          cat > start_app.sh << 'SCRIPTEOF'
          #!/bin/bash
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          cd "$SCRIPT_DIR"
          source venv/bin/activate
          export FLASK_APP=udp_flask_server.py
          python udp_flask_server.py
          SCRIPTEOF
          
          chmod +x start_app.sh
          
          # Verificar que el script se cre√≥ correctamente
          echo "üìÑ Contenido del script de inicio:"
          cat start_app.sh
          
          # Iniciar la aplicaci√≥n con PM2
          echo "üöÄ Iniciando aplicaci√≥n Flask con PM2..."
          pm2 start start_app.sh \
            --name flask-app-${SUBDOMAIN} \
            --interpreter bash \
            --cwd $PROJECT_PATH \
            --log-date-format "YYYY-MM-DD HH:mm:ss"
          
          # Guardar configuraci√≥n de PM2
          pm2 save
          
          # Esperar a que la aplicaci√≥n inicie
          echo "‚è≥ Esperando a que la aplicaci√≥n inicie..."
          sleep 10
          
          # Verificar estado del servicio
          echo "‚úÖ Verificando estado del servicio..."
          pm2 status flask-app-${SUBDOMAIN}
          
          # Mostrar logs recientes
          echo "üìÑ √öltimos logs de la aplicaci√≥n:"
          pm2 logs flask-app-${SUBDOMAIN} --lines 20 --nostream || true
          
          # Test de conectividad
          echo "üß™ Probando conectividad..."
          
          # Verificar que Python puede importar las librer√≠as
          echo "Verificando dependencias Python..."
          cd $PROJECT_PATH
          source venv/bin/activate
          python -c "import flask; import psycopg2; import dotenv; print('‚úÖ Todas las dependencias Python est√°n instaladas')"
          
          # Probar conectividad HTTP local
          if curl -s -f http://localhost:5000/ > /dev/null 2>&1; then
            echo "‚úÖ Flask respondiendo en puerto 5000"
          else
            echo "‚ö†Ô∏è Flask no responde en puerto 5000"
            echo "Verificando proceso..."
            ps aux | grep -E "(python|flask)" | grep -v grep || true
            echo "Verificando puerto 5000..."
            sudo netstat -tlnp | grep :5000 || true
          fi
          
          # Probar conectividad HTTP a trav√©s de Nginx
          if curl -s -f http://localhost/ > /dev/null 2>&1; then
            echo "‚úÖ Nginx respondiendo en puerto 80"
          else
            echo "‚ö†Ô∏è Nginx no responde en puerto 80"
            echo "Estado de Nginx:"
            sudo systemctl status nginx --no-pager || true
          fi
          
          # Probar el dominio (si el DNS ya est√° propagado)
          echo "üåê Probando acceso por dominio..."
          if curl -s -f -H "Host: ${FULL_DOMAIN}" http://localhost/ > /dev/null 2>&1; then
            echo "‚úÖ El sitio responde correctamente con el header Host: ${FULL_DOMAIN}"
          else
            echo "‚ö†Ô∏è El sitio no responde con el header Host: ${FULL_DOMAIN}"
          fi
          
          # Configurar firewall si UFW est√° instalado
          if command -v ufw &> /dev/null; then
            echo "üîí Configurando firewall UFW..."
            sudo ufw allow 80/tcp comment "HTTP"
            sudo ufw allow 443/tcp comment "HTTPS"
            sudo ufw allow 5049/udp comment "UDP Listener"
            sudo ufw allow 22/tcp comment "SSH"
            echo "‚úÖ Reglas de firewall configuradas"
          fi
          
          # Opcional: Preparar para HTTPS con Let's Encrypt
          echo "üîê Preparando para HTTPS (opcional)..."
          sudo apt-get install -y certbot python3-certbot-nginx
          
          # Crear script para habilitar HTTPS
          cat > enable_https.sh << HTTPSEOF
          #!/bin/bash
          echo "Habilitando HTTPS para ${FULL_DOMAIN}..."
          sudo certbot --nginx -d ${FULL_DOMAIN} --non-interactive --agree-tos --email admin@${DOMAIN_BASE} --redirect
          echo "‚úÖ HTTPS habilitado. El sitio ahora redirige autom√°ticamente a HTTPS"
          HTTPSEOF
          chmod +x enable_https.sh
          
          # Informaci√≥n de conexi√≥n
          echo ""
          echo "========================================="
          echo "üéâ DESPLIEGUE COMPLETADO EXITOSAMENTE"
          echo "========================================="
          echo ""
          echo "üìä RESUMEN DE LA CONFIGURACI√ìN:"
          echo "   - Instancia: ${NAME}"
          echo "   - Subdominio: ${SUBDOMAIN}"
          echo "   - Dominio completo: ${FULL_DOMAIN}"
          echo "   - IP del servidor: ${HOST_IP}"
          echo "   - Proyecto en: $PROJECT_PATH"
          echo "   - Aplicaci√≥n PM2: flask-app-${SUBDOMAIN}"
          echo "   - Puerto Flask: 5000 (interno)"
          echo "   - Puerto Nginx: 80 (p√∫blico)"
          echo ""
          echo "üìÅ UBICACI√ìN DE LOGS:"
          echo "   - Nginx Access: /var/log/nginx/${SUBDOMAIN}_access.log"
          echo "   - Nginx Error: /var/log/nginx/${SUBDOMAIN}_error.log"
          echo "   - PM2: pm2 logs flask-app-${SUBDOMAIN}"
          echo ""
          echo "üîó URLS DE ACCESO:"
          echo "   - http://${FULL_DOMAIN}"
          echo "   - http://${HOST_IP} (redirige a ${FULL_DOMAIN})"
          echo ""
          echo "üîê PARA HABILITAR HTTPS:"
          echo "   Ejecuta: ./enable_https.sh"
          echo ""
          echo "üõ†Ô∏è COMANDOS √öTILES:"
          echo "   - Ver logs en tiempo real: pm2 logs flask-app-${SUBDOMAIN}"
          echo "   - Reiniciar aplicaci√≥n: pm2 restart flask-app-${SUBDOMAIN}"
          echo "   - Ver estado: pm2 status"
          echo "   - Monitoreo: pm2 monit"
          echo ""
          echo "üìä Estado actual de PM2:"
          pm2 list
          echo ""
          echo "========================================="
          
        ENDSSH
        
        # Limpiar archivos temporales
        rm -f deploy_key temp_env_file
        
        echo "‚úÖ Script de despliegue finalizado para instancia ${{ matrix.instance }}"