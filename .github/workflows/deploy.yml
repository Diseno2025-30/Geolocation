name: Deploy Flask App to 4 EC2 Instances

on:
  push:
    branches: [ main ]
    paths:
      # Se activa si hay cambios en el proyecto o el propio workflow
      - 'Proyecto_1_Diseno/**'
      - '.github/workflows/deploy.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false # Si un despliegue falla, los otros continuar√°n.
      matrix:
        # Define las 4 instancias en las que se desplegar√°
        instance: [1, 2, 3, 4]

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Deploy to EC2 Instance ${{ matrix.instance }}
      env:
        # Selecciona los secretos de GitHub din√°micamente para cada instancia
        HOST: ${{ secrets[format('EC2_HOST_{0}', matrix.instance)] }}
        USER: ${{ secrets[format('EC2_USER_{0}', matrix.instance)] }}
        KEY: ${{ secrets[format('EC2_SSH_KEY_{0}', matrix.instance)] }}
        ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', matrix.instance)] }}
        DOMAIN_BASE: tumaquinaya.com
      run: |
        echo "üöÄ Iniciando despliegue en la instancia ${{ matrix.instance }}..."
        
        # Crear el archivo de llave SSH temporalmente
        echo "$KEY" > deploy_key
        chmod 600 deploy_key
        
        # Crear archivo .env temporal con expansi√≥n de variable
        echo "$ENV_FILE" > temp_env_file
        
        # Extraer el NAME del archivo .env para usarlo como subdominio
        NAME_VALUE=$(grep "^NAME=" temp_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | tr '[:upper:]' '[:lower:]' | xargs)
        
        if [ -z "$NAME_VALUE" ]; then
            echo "‚ö†Ô∏è No se encontr√≥ NAME en .env, usando instance-${{ matrix.instance }}"
            NAME_VALUE="instance-${{ matrix.instance }}"
        fi
        
        # Construir el dominio completo
        FULL_DOMAIN="${NAME_VALUE}.${DOMAIN_BASE}"
        
        echo "üìã Configuraci√≥n detectada:"
        echo "   - NAME (subdominio): ${NAME_VALUE}"
        echo "   - Dominio completo: ${FULL_DOMAIN}"
        echo "   - IP del servidor: ${HOST}"
        
        # Transferir script de despliegue y ejecutarlo
        echo "üìù Creando script de despliegue remoto..."
        cat > deploy_remote.sh << 'DEPLOYEOF'
        #!/bin/bash
        set -e

        # Recibir par√°metros
        SUBDOMAIN="${1}"
        DOMAIN_BASE="${2}"
        INSTANCE_NUM="${3}"

        echo "üîß Configuraci√≥n recibida:"
        echo "   - Subdominio: ${SUBDOMAIN}"
        echo "   - Dominio base: ${DOMAIN_BASE}"
        echo "   - Instancia: ${INSTANCE_NUM}"

        # Determinar ruta del proyecto
        if [ -d "/home/ubuntu/Web-server-UDP" ]; then
          echo "üìÅ Usando proyecto existente en /home/ubuntu/Web-server-UDP"
          cd /home/ubuntu/Web-server-UDP
        else
          echo "üìÅ Usando/creando estructura en /opt/location-tracker"
          sudo mkdir -p /opt/location-tracker
          sudo chown $USER:$USER /opt/location-tracker
          cd /opt/location-tracker
        fi

        # Guardar commit actual antes de actualizar
        echo "üì¶ Actualizando c√≥digo desde Git..."
        if [ -d .git ]; then
          BEFORE_PULL=$(git rev-parse HEAD 2>/dev/null || echo "none")
          git fetch origin main
          git reset --hard origin/main
          AFTER_PULL=$(git rev-parse HEAD)
          
          if [ "$BEFORE_PULL" != "$AFTER_PULL" ]; then
            echo "‚úÖ C√≥digo actualizado exitosamente"
            echo "Cambios aplicados:"
            if [ "$BEFORE_PULL" != "none" ]; then
              git log --oneline ${BEFORE_PULL}..${AFTER_PULL} | head -10
            fi
            CODE_UPDATED=true
          else
            echo "‚ÑπÔ∏è Ya tienes la √∫ltima versi√≥n del c√≥digo"
            CODE_UPDATED=false
          fi
        else
          echo "üì• Clonando repositorio por primera vez..."
          git clone https://github.com/Diseno2025-30/Geolocation.git .
          CODE_UPDATED=true
        fi

        # Navegar al directorio del proyecto
        cd Proyecto_1_Diseno

        # Determinar ruta completa
        PROJECT_PATH=$(pwd)
        echo "üìÇ Trabajando en: $PROJECT_PATH"

        # Verificar el archivo .env
        echo "üìã Verificando archivo .env..."
        if [ -f .env ]; then
          source .env 2>/dev/null || true
          
          # Si tenemos NAME del .env, √∫salo
          if [ ! -z "$NAME" ]; then
            SUBDOMAIN=$(echo "$NAME" | tr '[:upper:]' '[:lower:]' | xargs)
            echo "‚úÖ Usando NAME del .env: ${NAME} -> ${SUBDOMAIN}"
          fi
        fi

        # Construir nombres finales
        FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
        APP_NAME="flask-app-${SUBDOMAIN}"

        echo "üìä Configuraci√≥n final:"
        echo "   - APP_NAME: ${APP_NAME}"
        echo "   - FULL_DOMAIN: ${FULL_DOMAIN}"
        echo "   - PROJECT_PATH: ${PROJECT_PATH}"

        # Instalar dependencias del sistema si es necesario
        echo "üì¶ Verificando dependencias del sistema..."

        # Node.js y npm
        if ! command -v node &> /dev/null; then
          echo "Instalando Node.js..."
          curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
          sudo apt-get install -y nodejs
        fi

        # PM2
        if ! command -v pm2 &> /dev/null; then
          echo "Instalando PM2..."
          sudo npm install -g pm2
          pm2 startup systemd -u $USER --hp /home/$USER
        fi

        # Python y Nginx
        sudo apt-get update -qq
        sudo apt-get install -y python3-pip python3-venv nginx

        # Configurar entorno virtual de Python
        echo "üêç Configurando entorno Python..."
        if [ ! -d "venv" ]; then
          python3 -m venv venv
        fi

        source venv/bin/activate
        pip install --upgrade pip
        pip install flask psycopg2-binary python-dotenv

        # Si existe requirements.txt, instalarlo tambi√©n
        if [ -f requirements.txt ]; then
          pip install -r requirements.txt
        fi

        # Configurar Nginx con subdominios
        echo "üåê Configurando Nginx..."
        cat > /tmp/nginx-config << NGINXCONF
        server {
            listen 80;
            server_name ${FULL_DOMAIN};
            
            access_log /var/log/nginx/${SUBDOMAIN}_access.log;
            error_log /var/log/nginx/${SUBDOMAIN}_error.log;
            
            location / {
                proxy_pass http://localhost:5000;
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_connect_timeout 60s;
                proxy_send_timeout 60s;
                proxy_read_timeout 60s;
                proxy_buffering off;
            }
            
            location /static {
                alias ${PROJECT_PATH}/static;
                expires 30d;
            }
        }

        server {
            listen 80;
            server_name www.${FULL_DOMAIN};
            return 301 http://${FULL_DOMAIN}\$request_uri;
        }

        # Server block por defecto para compatibilidad
        server {
            listen 80 default_server;
            server_name _;
            
            location / {
                proxy_pass http://localhost:5000;
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
            }
        }
        NGINXCONF

        sudo mv /tmp/nginx-config /etc/nginx/sites-available/location-tracker
        sudo ln -sf /etc/nginx/sites-available/location-tracker /etc/nginx/sites-enabled/
        sudo rm -f /etc/nginx/sites-enabled/default

        if sudo nginx -t; then
          sudo systemctl reload nginx
          echo "‚úÖ Nginx configurado correctamente"
        else
          echo "‚ùå Error en configuraci√≥n de Nginx"
          exit 1
        fi

        # Crear script de inicio si no existe o si hay cambios en el c√≥digo
        if [ ! -f "start_app.sh" ] || [ "$CODE_UPDATED" = "true" ]; then
          echo "üìù Actualizando script de inicio..."
          cat > start_app.sh << 'STARTSCRIPT'
        #!/bin/bash
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        cd "$SCRIPT_DIR"
        source venv/bin/activate
        export FLASK_APP=udp_flask_server.py
        export FLASK_ENV=production
        python udp_flask_server.py
        STARTSCRIPT
          chmod +x start_app.sh
        fi

        # IMPORTANTE: Limpiar aplicaciones PM2 antiguas que puedan estar en conflicto
        echo "üßπ Limpiando aplicaciones PM2 antiguas..."

        # Primero, detener TODAS las aplicaciones Flask antiguas que puedan estar usando el puerto
        pm2 list | grep -E "flask-app-[0-9]+" | awk '{print $2}' | while read old_app; do
          if [ "$old_app" != "$APP_NAME" ]; then
            echo "Deteniendo aplicaci√≥n antigua: $old_app"
            pm2 stop "$old_app" 2>/dev/null || true
            pm2 delete "$old_app" 2>/dev/null || true
          fi
        done

        # Tambi√©n detener cualquier flask-app-{numero} que pueda estar corriendo
        pm2 stop "flask-app-${INSTANCE_NUM}" 2>/dev/null || true
        pm2 delete "flask-app-${INSTANCE_NUM}" 2>/dev/null || true

        # Matar cualquier proceso Python que est√© usando el puerto 5000
        echo "üîç Verificando puerto 5000..."
        if sudo lsof -i :5000 &>/dev/null; then
          echo "‚ö†Ô∏è Puerto 5000 en uso, liber√°ndolo..."
          sudo fuser -k 5000/tcp 2>/dev/null || true
          sleep 2
        fi

        # Gestionar la aplicaci√≥n PM2
        echo "üöÄ Gestionando aplicaci√≥n con PM2..."

        if pm2 list | grep -q "${APP_NAME}"; then
          if [ "$CODE_UPDATED" = "true" ]; then
            echo "üîÑ C√≥digo actualizado, recargando aplicaci√≥n ${APP_NAME}..."
            pm2 reload ${APP_NAME} --update-env
            echo "‚úÖ Aplicaci√≥n recargada con los nuevos cambios"
          else
            echo "‚ÑπÔ∏è No hay cambios de c√≥digo, verificando estado de ${APP_NAME}..."
            pm2 status ${APP_NAME}
            
            # Si la app est√° detenida o con error, reiniciarla
            if pm2 list | grep "${APP_NAME}" | grep -E "(stopped|errored)"; then
              echo "‚ö†Ô∏è Aplicaci√≥n detenida o con error, reiniciando..."
              pm2 restart ${APP_NAME}
            fi
          fi
        else
          echo "üÜï Iniciando nueva aplicaci√≥n ${APP_NAME}..."
          pm2 start start_app.sh \
            --name ${APP_NAME} \
            --interpreter bash \
            --cwd $PROJECT_PATH \
            --log-date-format "YYYY-MM-DD HH:mm:ss" \
            --max-restarts 3 \
            --restart-delay 3000
        fi

        # Guardar configuraci√≥n de PM2
        pm2 save

        # Esperar y verificar
        echo "‚è≥ Esperando a que la aplicaci√≥n est√© lista..."
        sleep 5

        # Verificaci√≥n de estado
        echo "üìä Estado de la aplicaci√≥n:"
        pm2 status ${APP_NAME}

        # Mostrar √∫ltimos logs
        echo "üìÑ √öltimos logs:"
        pm2 logs ${APP_NAME} --lines 15 --nostream || true

        # Tests de conectividad
        echo "üß™ Realizando pruebas de conectividad..."

        # Test Flask
        MAX_RETRIES=5
        RETRY=0
        while [ $RETRY -lt $MAX_RETRIES ]; do
          if curl -s -f http://localhost:5000/ > /dev/null 2>&1; then
            echo "‚úÖ Flask respondiendo correctamente en puerto 5000"
            break
          else
            RETRY=$((RETRY + 1))
            if [ $RETRY -lt $MAX_RETRIES ]; then
              echo "‚è≥ Esperando a Flask (intento $RETRY/$MAX_RETRIES)..."
              sleep 2
            else
              echo "‚ö†Ô∏è Flask no responde despu√©s de $MAX_RETRIES intentos"
              echo "Debug - Procesos Python:"
              ps aux | grep python | grep -v grep || true
              echo "Debug - Puerto 5000:"
              sudo netstat -tlnp | grep :5000 || true
            fi
          fi
        done

        # Test Nginx
        if curl -s -f http://localhost/ > /dev/null 2>&1; then
          echo "‚úÖ Nginx respondiendo correctamente en puerto 80"
        else
          echo "‚ö†Ô∏è Nginx no responde"
        fi

        # Test con dominio
        if curl -s -f -H "Host: ${FULL_DOMAIN}" http://localhost/ > /dev/null 2>&1; then
          echo "‚úÖ Sitio accesible via ${FULL_DOMAIN}"
        else
          echo "‚ö†Ô∏è Sitio no responde con dominio ${FULL_DOMAIN}"
        fi

        # Configurar firewall
        if command -v ufw &> /dev/null; then
          echo "üîí Configurando firewall..."
          sudo ufw allow 80/tcp comment "HTTP" 2>/dev/null || true
          sudo ufw allow 443/tcp comment "HTTPS" 2>/dev/null || true
          sudo ufw allow 5049/udp comment "UDP Listener" 2>/dev/null || true
          sudo ufw allow 22/tcp comment "SSH" 2>/dev/null || true
        fi

        # Resumen final
        echo ""
        echo "========================================="
        if [ "$CODE_UPDATED" = "true" ]; then
          echo "üéâ C√ìDIGO ACTUALIZADO Y DESPLEGADO"
        else
          echo "‚úÖ DESPLIEGUE VERIFICADO"
        fi
        echo "========================================="
        echo ""
        echo "üìä CONFIGURACI√ìN:"
        echo "   - Aplicaci√≥n: ${APP_NAME}"
        echo "   - Dominio: ${FULL_DOMAIN}"
        echo "   - Proyecto: ${PROJECT_PATH}"
        echo "   - Estado: $(pm2 list | grep ${APP_NAME} | awk '{print $10}')"
        echo ""
        echo "üîó ACCESO:"
        echo "   - http://${FULL_DOMAIN}"
        echo ""
        echo "üõ†Ô∏è COMANDOS:"
        echo "   - Ver logs: pm2 logs ${APP_NAME}"
        echo "   - Reiniciar: pm2 restart ${APP_NAME}"
        echo "   - Recargar: pm2 reload ${APP_NAME}"
        echo "   - Monitorear: pm2 monit"
        echo ""
        echo "üìä Aplicaciones PM2 activas:"
        pm2 list
        echo "========================================="
        DEPLOYEOF
        
        # Transferir archivos al servidor
        echo "üì§ Transfiriendo archivos al servidor..."
        
        # Determinar la ruta del proyecto
        PROJECT_PATH=$(ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} '
          if [ -d "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno" ]; then
            echo "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno"
          else
            echo "/opt/location-tracker/Proyecto_1_Diseno"
          fi
        ')
        
        # Transferir .env
        scp -o StrictHostKeyChecking=no -i deploy_key temp_env_file ${USER}@${HOST}:${PROJECT_PATH}/.env
        
        # Transferir y ejecutar script
        scp -o StrictHostKeyChecking=no -i deploy_key deploy_remote.sh ${USER}@${HOST}:/tmp/deploy_remote.sh
        
        echo "üöÄ Ejecutando despliegue..."
        ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} \
          "chmod +x /tmp/deploy_remote.sh && /tmp/deploy_remote.sh '${NAME_VALUE}' '${DOMAIN_BASE}' '${{ matrix.instance }}' && rm /tmp/deploy_remote.sh"
        
        # Limpiar archivos temporales
        rm -f deploy_key temp_env_file deploy_remote.sh
        
        echo "‚úÖ Despliegue completado para instancia ${{ matrix.instance }}"