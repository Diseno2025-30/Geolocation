name: Deploy Flask App to 4 EC2 Instances

on:
  push:
    branches: [ main ]
    paths:
      # Se activa si hay cambios en el proyecto o el propio workflow
      - 'Proyecto_1_Diseno/**'
      - '.github/workflows/deploy.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false # Si un despliegue falla, los otros continuar√°n.
      matrix:
        # Define las 4 instancias en las que se desplegar√°
        instance: [1, 2, 3, 4]

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Deploy to EC2 Instance ${{ matrix.instance }}
      env:
        # Selecciona los secretos de GitHub din√°micamente para cada instancia
        HOST: ${{ secrets[format('EC2_HOST_{0}', matrix.instance)] }}
        USER: ${{ secrets[format('EC2_USER_{0}', matrix.instance)] }}
        KEY: ${{ secrets[format('EC2_SSH_KEY_{0}', matrix.instance)] }}
        ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', matrix.instance)] }}
        DOMAIN_BASE: tumaquinaya.com
      run: |
        echo "üöÄ Iniciando despliegue en la instancia ${{ matrix.instance }}..."
        
        # Crear el archivo de llave SSH temporalmente
        echo "$KEY" > deploy_key
        chmod 600 deploy_key
        
        # Crear archivo .env temporal con expansi√≥n de variable
        echo "$ENV_FILE" > temp_env_file
        
        # Extraer el NAME del archivo .env para usarlo como subdominio
        NAME_VALUE=$(grep "^NAME=" temp_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | tr '[:upper:]' '[:lower:]' | xargs)
        
        if [ -z "$NAME_VALUE" ]; then
            echo "‚ùå Error: No se encontr√≥ la variable NAME en el archivo .env"
            echo "Contenido del archivo .env (primeras l√≠neas):"
            head -5 temp_env_file
            exit 1
        fi
        
        # Construir el dominio completo
        FULL_DOMAIN="${NAME_VALUE}.${DOMAIN_BASE}"
        
        echo "üìã Configuraci√≥n detectada:"
        echo "   - NAME (subdominio): ${NAME_VALUE}"
        echo "   - Dominio completo: ${FULL_DOMAIN}"
        echo "   - IP del servidor: ${HOST}"
        echo "   - Tama√±o del archivo .env: $(wc -c < temp_env_file) bytes"
        
        # Script de despliegue remoto v√≠a SSH - Primera parte: preparar proyecto
        ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} '
          # 0. Usar la ubicaci√≥n existente o crear nueva
          if [ -d "/home/ubuntu/Web-server-UDP" ]; then
            echo "üìÅ Usando proyecto existente en /home/ubuntu/Web-server-UDP"
            cd /home/ubuntu/Web-server-UDP
          else
            echo "üìÅ Creando nueva estructura en /opt/location-tracker"
            sudo mkdir -p /opt/location-tracker
            sudo chown $USER:$USER /opt/location-tracker
            cd /opt/location-tracker
          fi
          
          # 1. Actualizar el c√≥digo desde el repositorio
          echo "üì¶ Actualizando c√≥digo desde Git..."
          if [ -d .git ]; then
            # Guardar el commit actual
            BEFORE_PULL=$(git rev-parse HEAD)
            git pull origin main
            AFTER_PULL=$(git rev-parse HEAD)
            
            if [ "$BEFORE_PULL" != "$AFTER_PULL" ]; then
              echo "‚úÖ Se detectaron cambios:"
              git log --oneline ${BEFORE_PULL}..${AFTER_PULL}
            else
              echo "‚ÑπÔ∏è No hay cambios nuevos en el c√≥digo"
            fi
          else
            git clone https://github.com/${{ github.repository }}.git .
          fi
          
          # 2. Navegar al directorio del proyecto
          cd Proyecto_1_Diseno
        '
        
        # 3. Determinar la ruta correcta del proyecto
        echo "‚öôÔ∏è Determinando ruta del proyecto..."
        PROJECT_PATH=$(ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} '
          if [ -d "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno" ]; then
            echo "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno"
          else
            echo "/opt/location-tracker/Proyecto_1_Diseno"
          fi
        ')
        
        echo "üìÇ Ruta del proyecto: $PROJECT_PATH"
        
        # 4. Transferir archivo .env
        echo "üì§ Transfiriendo archivo .env..."
        scp -o StrictHostKeyChecking=no -i deploy_key temp_env_file ${USER}@${HOST}:${PROJECT_PATH}/.env
        
        # 5. Transferir script de despliegue y ejecutarlo
        echo "üìù Creando script de despliegue remoto..."
        cat > deploy_remote.sh << 'DEPLOYEOF'
        #!/bin/bash
        # Variables base
        DOMAIN_BASE="tumaquinaya.com"
        HOST_IP="${1}"

        # Determinar ruta del proyecto
        if [ -d "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno" ]; then
          PROJECT_PATH="/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno"
        else
          PROJECT_PATH="/opt/location-tracker/Proyecto_1_Diseno"
        fi

        # Ir al directorio del proyecto
        cd $PROJECT_PATH

        echo "üîß Verificando formato del archivo .env..."

        # Intentar cargar las variables del archivo .env
        set +e
        source .env 2>/dev/null
        set -e

        # Si NAME est√° vac√≠o, intentar extraerlo directamente del archivo
        if [ -z "$NAME" ]; then
          echo "‚ö†Ô∏è NAME vac√≠o, intentando extraer directamente del archivo..."
          NAME=$(grep "^NAME=" .env | cut -d'=' -f2 | tr -d '"' | tr -d "'" | xargs)
        fi

        # Validar que NAME existe
        if [ -z "$NAME" ]; then
          echo "‚ùå Error: No se pudo obtener la variable NAME del archivo .env"
          echo "Contenido del archivo .env:"
          cat .env
          exit 1
        fi

        # Convertir NAME a min√∫sculas para usar como subdominio
        SUBDOMAIN=$(echo "$NAME" | tr '[:upper:]' '[:lower:]' | xargs)
        FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
        APP_NAME="flask-app-${SUBDOMAIN}"

        # Exportar variables
        export SUBDOMAIN
        export FULL_DOMAIN
        export HOST_IP
        export PROJECT_PATH
        export APP_NAME

        # Verificar configuraci√≥n
        echo "üìã Verificando configuraci√≥n..."
        echo "Variables de entorno:"
        echo "  - NAME: ${NAME}"
        echo "  - SUBDOMAIN: ${SUBDOMAIN}"
        echo "  - DOMINIO COMPLETO: ${FULL_DOMAIN}"
        echo "  - APP_NAME: ${APP_NAME}"
        echo "  - Variables DB: [CONFIGURADAS]"

        # Validar que el subdominio no est√© vac√≠o
        if [ -z "$SUBDOMAIN" ]; then
          echo "‚ùå Error: SUBDOMAIN est√° vac√≠o"
          exit 1
        fi

        # Instalar Node.js si no est√° instalado
        echo "üì¶ Verificando Node.js y npm..."
        if ! command -v node &> /dev/null; then
          echo "Instalando Node.js..."
          curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
          sudo apt-get install -y nodejs
        fi

        # Instalar PM2 si no est√° instalado
        echo "‚ö° Verificando PM2..."
        if ! command -v pm2 &> /dev/null; then
          echo "Instalando PM2..."
          sudo npm install -g pm2
          pm2 startup systemd -u $USER --hp /home/$USER
        fi

        # Instalar dependencias de Python
        echo "üìã Configurando entorno virtual de Python..."
        sudo apt-get update
        sudo apt-get install -y python3-pip python3-venv nginx

        # Crear entorno virtual si no existe
        if [ ! -d "venv" ]; then
          python3 -m venv venv
        fi

        # Activar entorno virtual e instalar dependencias
        source venv/bin/activate
        pip install flask psycopg2-binary python-dotenv

        # Si existe requirements.txt, instalarlo
        if [ -f requirements.txt ]; then
          pip install -r requirements.txt
        fi

        # Configurar Nginx
        echo "üåê Configurando Nginx proxy reverso para ${FULL_DOMAIN}..."

        # Crear configuraci√≥n de Nginx
        cat > /tmp/nginx-config << NGINXCONF
        server {
            listen 80;
            server_name ${FULL_DOMAIN};
            
            access_log /var/log/nginx/${SUBDOMAIN}_access.log;
            error_log /var/log/nginx/${SUBDOMAIN}_error.log;
            
            location / {
                proxy_pass http://localhost:5000;
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_connect_timeout 60s;
                proxy_send_timeout 60s;
                proxy_read_timeout 60s;
                proxy_buffering off;
            }
            
            location /static {
                alias ${PROJECT_PATH}/static;
                expires 30d;
                add_header Cache-Control "public, immutable";
            }
        }

        server {
            listen 80;
            server_name ${HOST_IP};
            return 301 http://${FULL_DOMAIN}\$request_uri;
        }

        server {
            listen 80;
            server_name www.${FULL_DOMAIN};
            return 301 http://${FULL_DOMAIN}\$request_uri;
        }

        server {
            listen 80 default_server;
            server_name _;
            
            location / {
                proxy_pass http://localhost:5000;
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
            }
        }
        NGINXCONF

        sudo mv /tmp/nginx-config /etc/nginx/sites-available/location-tracker
        sudo ln -sf /etc/nginx/sites-available/location-tracker /etc/nginx/sites-enabled/
        sudo rm -f /etc/nginx/sites-enabled/default

        # Verificar y recargar Nginx
        echo "üîç Verificando configuraci√≥n de Nginx..."
        if sudo nginx -t; then
          echo "‚úÖ Configuraci√≥n de Nginx v√°lida"
          sudo systemctl reload nginx
          sudo systemctl enable nginx
        else
          echo "‚ùå Error en la configuraci√≥n de Nginx"
          sudo cat /etc/nginx/sites-available/location-tracker
          exit 1
        fi

        # Crear script de inicio para PM2
        echo "üìù Creando script de inicio..."
        cat > start_app.sh << 'STARTSCRIPT'
        #!/bin/bash
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        cd "$SCRIPT_DIR"
        source venv/bin/activate
        export FLASK_APP=udp_flask_server.py
        python udp_flask_server.py
        STARTSCRIPT

        chmod +x start_app.sh

        # Verificar que el script se cre√≥ correctamente
        if [ -f start_app.sh ]; then
          echo "‚úÖ Script creado correctamente"
        else
          echo "‚ùå Error: No se pudo crear el script de inicio"
          exit 1
        fi

        # Gestionar aplicaci√≥n con PM2
        if pm2 list | grep -q "${APP_NAME}"; then
          echo "üîÑ La aplicaci√≥n ${APP_NAME} ya est√° corriendo, recargando..."
          pm2 reload ${APP_NAME} --update-env
          echo "‚úÖ Aplicaci√≥n recargada con los √∫ltimos cambios"
        else
          echo "üöÄ Iniciando nueva aplicaci√≥n Flask con PM2..."
          pm2 start start_app.sh \
            --name ${APP_NAME} \
            --interpreter bash \
            --cwd $PROJECT_PATH \
            --log-date-format "YYYY-MM-DD HH:mm:ss"
          echo "‚úÖ Nueva aplicaci√≥n iniciada"
        fi

        # Guardar configuraci√≥n de PM2
        pm2 save

        # Esperar a que la aplicaci√≥n inicie
        echo "‚è≥ Esperando a que la aplicaci√≥n inicie..."
        sleep 10

        # Verificar estado del servicio
        echo "‚úÖ Verificando estado del servicio..."
        pm2 status ${APP_NAME}

        # Mostrar logs recientes
        echo "üìÑ √öltimos logs de la aplicaci√≥n:"
        pm2 logs ${APP_NAME} --lines 20 --nostream || true

        # Test de conectividad
        echo "üß™ Probando conectividad..."

        # Verificar dependencias Python
        cd $PROJECT_PATH
        source venv/bin/activate
        python -c "import flask; import psycopg2; import dotenv; print('‚úÖ Todas las dependencias Python est√°n instaladas')"

        # Probar conectividad HTTP
        if curl -s -f http://localhost:5000/ > /dev/null 2>&1; then
          echo "‚úÖ Flask respondiendo en puerto 5000"
        else
          echo "‚ö†Ô∏è Flask no responde en puerto 5000"
          ps aux | grep -E "(python|flask)" | grep -v grep || true
          sudo netstat -tlnp | grep :5000 || true
        fi

        if curl -s -f http://localhost/ > /dev/null 2>&1; then
          echo "‚úÖ Nginx respondiendo en puerto 80"
        else
          echo "‚ö†Ô∏è Nginx no responde en puerto 80"
          sudo systemctl status nginx --no-pager || true
        fi

        # Probar el dominio
        echo "üåê Probando acceso por dominio..."
        if curl -s -f -H "Host: ${FULL_DOMAIN}" http://localhost/ > /dev/null 2>&1; then
          echo "‚úÖ El sitio responde correctamente con el header Host: ${FULL_DOMAIN}"
        else
          echo "‚ö†Ô∏è El sitio no responde con el header Host: ${FULL_DOMAIN}"
        fi

        # Configurar firewall si UFW est√° instalado
        if command -v ufw &> /dev/null; then
          echo "üîí Configurando firewall UFW..."
          sudo ufw allow 80/tcp comment "HTTP"
          sudo ufw allow 443/tcp comment "HTTPS"
          sudo ufw allow 5049/udp comment "UDP Listener"
          sudo ufw allow 22/tcp comment "SSH"
          echo "‚úÖ Reglas de firewall configuradas"
        fi

        # Informaci√≥n final
        echo ""
        echo "========================================="
        echo "üéâ DESPLIEGUE COMPLETADO EXITOSAMENTE"
        echo "========================================="
        echo ""
        echo "üìä RESUMEN DE LA CONFIGURACI√ìN:"
        echo "   - Instancia: ${NAME}"
        echo "   - Subdominio: ${SUBDOMAIN}"
        echo "   - Dominio completo: ${FULL_DOMAIN}"
        echo "   - IP del servidor: ${HOST_IP}"
        echo "   - Proyecto en: $PROJECT_PATH"
        echo "   - Aplicaci√≥n PM2: ${APP_NAME}"
        echo "   - Puerto Flask: 5000 (interno)"
        echo "   - Puerto Nginx: 80 (p√∫blico)"
        echo ""
        echo "üìÅ UBICACI√ìN DE LOGS:"
        echo "   - Nginx Access: /var/log/nginx/${SUBDOMAIN}_access.log"
        echo "   - Nginx Error: /var/log/nginx/${SUBDOMAIN}_error.log"
        echo "   - PM2: pm2 logs ${APP_NAME}"
        echo ""
        echo "üîó URLS DE ACCESO:"
        echo "   - http://${FULL_DOMAIN}"
        echo "   - http://${HOST_IP} (redirige a ${FULL_DOMAIN})"
        echo ""
        echo "üõ†Ô∏è COMANDOS √öTILES:"
        echo "   - Ver logs: pm2 logs ${APP_NAME}"
        echo "   - Reiniciar: pm2 restart ${APP_NAME}"
        echo "   - Recargar: pm2 reload ${APP_NAME}"
        echo "   - Estado: pm2 status"
        echo "   - Monitoreo: pm2 monit"
        echo ""
        echo "üìä Estado actual de PM2:"
        pm2 list
        echo ""
        echo "========================================="
        DEPLOYEOF
        
        # Transferir y ejecutar el script
        echo "üì§ Transfiriendo script de despliegue..."
        scp -o StrictHostKeyChecking=no -i deploy_key deploy_remote.sh ${USER}@${HOST}:/tmp/deploy_remote.sh
        
        echo "üöÄ Ejecutando script de despliegue..."
        ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} "chmod +x /tmp/deploy_remote.sh && /tmp/deploy_remote.sh '${HOST}' && rm /tmp/deploy_remote.sh"
        
        # Limpiar archivos temporales
        rm -f deploy_key temp_env_file deploy_remote.sh
        
        echo "‚úÖ Script de despliegue finalizado para instancia ${{ matrix.instance }}"