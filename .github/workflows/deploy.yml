name: Deploy Flask App to 4 EC2 Instances

on:
  push:
    branches: [ main ]
    paths:
      # Se activa si hay cambios en el proyecto o el propio workflow
      - 'Proyecto_1_Diseno/**'
      - '.github/workflows/deploy.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false # Si un despliegue falla, los otros continuar√°n.
      matrix:
        # Define las 4 instancias en las que se desplegar√°
        instance: [1, 2, 3, 4]

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Deploy to EC2 Instance ${{ matrix.instance }}
      env:
        # Selecciona los secretos de GitHub din√°micamente para cada instancia
        HOST: ${{ secrets[format('EC2_HOST_{0}', matrix.instance)] }}
        USER: ${{ secrets[format('EC2_USER_{0}', matrix.instance)] }}
        KEY: ${{ secrets[format('EC2_SSH_KEY_{0}', matrix.instance)] }}
        ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', matrix.instance)] }}
      run: |
        echo "üöÄ Iniciando despliegue en la instancia ${{ matrix.instance }}..."
        
        # Crear el archivo de llave SSH temporalmente
        echo "$KEY" > deploy_key
        chmod 600 deploy_key
        
        # Crear archivo .env temporal con expansi√≥n de variable
        echo "$ENV_FILE" > temp_env_file
        
        # Verificar localmente que el archivo se cre√≥ correctamente
        echo "üìã Verificando contenido del archivo .env local:"
        echo "Tama√±o del archivo: $(wc -c < temp_env_file) bytes"
        
        # Script de despliegue remoto v√≠a SSH - Primera parte: preparar proyecto
        ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} '
          # 0. Usar la ubicaci√≥n existente o crear nueva
          if [ -d "/home/ubuntu/Web-server-UDP" ]; then
            echo "üìÅ Usando proyecto existente en /home/ubuntu/Web-server-UDP"
            cd /home/ubuntu/Web-server-UDP
          else
            echo "üìÅ Creando nueva estructura en /opt/location-tracker"
            sudo mkdir -p /opt/location-tracker
            sudo chown $USER:$USER /opt/location-tracker
            cd /opt/location-tracker
          fi
          
          # 1. Actualizar el c√≥digo desde el repositorio
          echo "üì¶ Actualizando c√≥digo desde Git..."
          if [ -d .git ]; then
            git pull origin main
          else
            git clone https://github.com/${{ github.repository }}.git .
          fi
          
          # 2. Navegar al directorio del proyecto
          cd Proyecto_1_Diseno
        '
        
        # 3. Determinar la ruta correcta del proyecto
        echo "‚öôÔ∏è Determinando ruta del proyecto..."
        PROJECT_PATH=$(ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} '
          if [ -d "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno" ]; then
            echo "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno"
          else
            echo "/opt/location-tracker/Proyecto_1_Diseno"
          fi
        ')
        
        echo "üìÇ Ruta del proyecto: $PROJECT_PATH"
        
        # 4. Transferir archivo .env
        echo "üì§ Transfiriendo archivo .env..."
        scp -o StrictHostKeyChecking=no -i deploy_key temp_env_file ${USER}@${HOST}:${PROJECT_PATH}/.env
        
        # 5. Continuar con el despliegue - Segunda parte
        ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} << 'ENDSSH'
          # Determinar ruta del proyecto
          if [ -d "/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno" ]; then
            PROJECT_PATH="/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno"
          else
            PROJECT_PATH="/opt/location-tracker/Proyecto_1_Diseno"
          fi
          
          # Ir al directorio del proyecto
          cd $PROJECT_PATH
          
          # Verificar que el .env se transfiri√≥ correctamente
          echo "üìã Verificando archivo .env..."
          ls -la .env
          echo "Variables de entorno (sin mostrar valores sensibles):"
          grep -E "^[A-Z_]+=" .env | cut -d= -f1
          
          # Actualizar sistema e instalar Node.js si no est√° instalado
          echo "üì¶ Verificando Node.js y npm..."
          if ! command -v node &> /dev/null; then
            echo "Instalando Node.js..."
            curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
            sudo apt-get install -y nodejs
          fi
          
          # Instalar PM2 globalmente si no est√° instalado
          echo "‚ö° Verificando PM2..."
          if ! command -v pm2 &> /dev/null; then
            echo "Instalando PM2..."
            sudo npm install -g pm2
            pm2 startup systemd -u $USER --hp /home/$USER
          fi
          
          # Instalar dependencias de Python con virtual environment
          echo "üìã Configurando entorno virtual de Python..."
          sudo apt-get update
          sudo apt-get install -y python3-pip python3-venv nginx
          
          # Crear entorno virtual si no existe
          if [ ! -d "venv" ]; then
            python3 -m venv venv
          fi
          
          # Activar entorno virtual e instalar dependencias
          source venv/bin/activate
          pip install flask psycopg2-binary python-dotenv
          
          # Si existe requirements.txt, instalarlo
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
          
          # Configurar Nginx como proxy reverso
          echo "üåê Configurando Nginx proxy reverso..."
          
          # Primero, desactivar el sitio default de Nginx si existe
          sudo rm -f /etc/nginx/sites-enabled/default
          
          # Crear configuraci√≥n de Nginx mejorada
          sudo tee /etc/nginx/sites-available/location-tracker > /dev/null << 'NGINXCONFIG'
        server {
            listen 80 default_server;
            listen [::]:80 default_server;
            server_name _;
            
            # Tama√±o m√°ximo de carga
            client_max_body_size 10M;
            
            # Timeouts
            proxy_connect_timeout 600;
            proxy_send_timeout 600;
            proxy_read_timeout 600;
            send_timeout 600;
            
            location / {
                proxy_pass http://127.0.0.1:5000;
                proxy_http_version 1.1;
                
                # Headers importantes para el proxy
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header X-Forwarded-Host $host;
                proxy_set_header X-Forwarded-Port $server_port;
                
                # WebSocket support (si lo necesitas en el futuro)
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "upgrade";
                
                # Evitar problemas de buffering
                proxy_buffering off;
                proxy_request_buffering off;
            }
            
            # Archivos est√°ticos (si los tienes)
            location /static {
                alias $PROJECT_PATH/static;
                expires 30d;
                add_header Cache-Control "public, immutable";
            }
            
            # Salud del servicio
            location /health {
                access_log off;
                return 200 "healthy\n";
                add_header Content-Type text/plain;
            }
        }

        # Configuraci√≥n HTTPS (se activar√° cuando tengas certificado SSL)
        server {
            listen 443 ssl http2 default_server;
            listen [::]:443 ssl http2 default_server;
            server_name _;
            
            # Los certificados se configurar√°n m√°s adelante con certbot
            # ssl_certificate /etc/letsencrypt/live/tu-dominio/fullchain.pem;
            # ssl_certificate_key /etc/letsencrypt/live/tu-dominio/privkey.pem;
            
            # Por ahora, generar certificado autofirmado para testing
            ssl_certificate /etc/nginx/ssl/self-signed.crt;
            ssl_certificate_key /etc/nginx/ssl/self-signed.key;
            
            # Configuraci√≥n SSL moderna
            ssl_protocols TLSv1.2 TLSv1.3;
            ssl_ciphers HIGH:!aNULL:!MD5;
            ssl_prefer_server_ciphers on;
            
            # Misma configuraci√≥n de proxy que HTTP
            client_max_body_size 10M;
            
            location / {
                proxy_pass http://127.0.0.1:5000;
                proxy_http_version 1.1;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto https;
                proxy_set_header X-Forwarded-Host $host;
                proxy_set_header X-Forwarded-Port 443;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "upgrade";
                proxy_buffering off;
                proxy_request_buffering off;
            }
            
            location /static {
                alias $PROJECT_PATH/static;
                expires 30d;
                add_header Cache-Control "public, immutable";
            }
            
            location /health {
                access_log off;
                return 200 "healthy\n";
                add_header Content-Type text/plain;
            }
        }
        NGINXCONFIG
          
          # Crear directorio para certificados SSL
          sudo mkdir -p /etc/nginx/ssl
          
          # Generar certificado autofirmado temporal (para testing HTTPS)
          sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout /etc/nginx/ssl/self-signed.key \
            -out /etc/nginx/ssl/self-signed.crt \
            -subj "/C=US/ST=State/L=City/O=Organization/CN=localhost"
          
          # Habilitar el sitio
          sudo ln -sf /etc/nginx/sites-available/location-tracker /etc/nginx/sites-enabled/location-tracker
          
          # Verificar configuraci√≥n
          sudo nginx -t
          
          # Reiniciar Nginx
          sudo systemctl restart nginx
          sudo systemctl enable nginx
          
          # Verificar que Nginx est√° escuchando en los puertos correctos
          echo "üîç Verificando puertos de Nginx..."
          sudo netstat -tlnp | grep -E ":(80|443)" || true
          
          # Detener aplicaci√≥n anterior si existe
          echo "üõë Deteniendo aplicaci√≥n anterior..."
          pm2 stop flask-app-${{ matrix.instance }} 2>/dev/null || echo "No hay aplicaci√≥n anterior corriendo"
          pm2 delete flask-app-${{ matrix.instance }} 2>/dev/null || echo "No hay aplicaci√≥n anterior que eliminar"
          
          # Crear script de inicio para PM2
          echo "üìù Creando script de inicio..."
          cat > start_app.sh << 'SCRIPTEOF'
            #!/bin/bash
            SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
            cd "$SCRIPT_DIR"
            source venv/bin/activate
            export FLASK_APP=udp_flask_server.py
            python udp_flask_server.py
            SCRIPTEOF
          
          chmod +x start_app.sh
          
          # Verificar que el script se cre√≥ correctamente
          echo "üìÑ Contenido del script de inicio:"
          cat start_app.sh
          
          # Iniciar la aplicaci√≥n con PM2
          echo "üöÄ Iniciando aplicaci√≥n Flask con PM2..."
          pm2 start start_app.sh \
            --name flask-app-${{ matrix.instance }} \
            --interpreter bash \
            --cwd $PROJECT_PATH \
            --log-date-format "YYYY-MM-DD HH:mm:ss"
          
          # Guardar configuraci√≥n de PM2
          pm2 save
          
          # Esperar a que la aplicaci√≥n inicie
          echo "‚è≥ Esperando a que la aplicaci√≥n inicie..."
          sleep 10
          
          # Verificar estado del servicio
          echo "‚úÖ Verificando estado del servicio..."
          pm2 status flask-app-${{ matrix.instance }}
          
          # Mostrar logs recientes
          echo "üìÑ √öltimos logs de la aplicaci√≥n:"
          pm2 logs flask-app-${{ matrix.instance }} --lines 20 --nostream || true
          
          # Test de conectividad
          echo "üß™ Probando conectividad..."
          
          # Verificar que Python puede importar las librer√≠as
          echo "Verificando dependencias Python..."
          cd $PROJECT_PATH
          source venv/bin/activate
          python -c "import flask; import psycopg2; import dotenv; print('‚úÖ Todas las dependencias Python est√°n instaladas')"
          
          # Esperar un poco m√°s para que los servicios se estabilicen
          sleep 5
          
          # Probar conectividad Flask directamente
          echo "üîç Verificando Flask en puerto 5000..."
          if curl -s -f -m 5 http://127.0.0.1:5000/ > /dev/null 2>&1; then
            echo "‚úÖ Flask respondiendo en puerto 5000"
          else
            echo "‚ö†Ô∏è Flask no responde en puerto 5000"
            echo "Verificando proceso Python..."
            ps aux | grep -E "(python|flask)" | grep -v grep || true
            echo "Verificando puerto 5000..."
            sudo netstat -tlnp | grep :5000 || true
          fi
          
          # Probar Nginx en puerto 80 (HTTP)
          echo "üîç Verificando Nginx en puerto 80..."
          if curl -s -f -m 5 http://localhost/ > /dev/null 2>&1; then
            echo "‚úÖ Nginx respondiendo en puerto 80 (HTTP)"
            echo "Respuesta de la aplicaci√≥n:"
            curl -s http://localhost/ | head -n 5 || true
          else
            echo "‚ö†Ô∏è Nginx no responde en puerto 80"
            echo "Estado de Nginx:"
            sudo systemctl status nginx --no-pager | head -n 10 || true
          fi
          
          # Probar Nginx en puerto 443 (HTTPS)
          echo "üîç Verificando Nginx en puerto 443..."
          if curl -s -f -m 5 -k https://localhost/ > /dev/null 2>&1; then
            echo "‚úÖ Nginx respondiendo en puerto 443 (HTTPS)"
          else
            echo "‚ö†Ô∏è Nginx no responde en puerto 443 (puede ser normal si no hay certificado)"
          fi
          
          # Verificar configuraci√≥n de firewall
          echo "üî• Verificando reglas de firewall..."
          sudo ufw status numbered 2>/dev/null || echo "UFW no est√° instalado"
          
          # Verificar grupos de seguridad (mostrar recordatorio)
          echo ""
          echo "‚ö†Ô∏è IMPORTANTE: Aseg√∫rate de que el Security Group de AWS permita:"
          echo "   - Puerto 80 (HTTP) desde 0.0.0.0/0"
          echo "   - Puerto 443 (HTTPS) desde 0.0.0.0/0"
          echo "   - Puerto 22 (SSH) desde tu IP"
          
          # Informaci√≥n de conexi√≥n
          echo ""
          echo "üéâ Despliegue completado en instancia ${{ matrix.instance }}"
          echo "üìä Resumen:"
          echo "   - Proyecto en: $PROJECT_PATH"
          echo "   - Aplicaci√≥n PM2: flask-app-${{ matrix.instance }}"
          echo ""
          echo "üåê URLs de acceso:"
          PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4 2>/dev/null || echo "IP no disponible")
          echo "   - HTTP:  http://$PUBLIC_IP/"
          echo "   - HTTPS: https://$PUBLIC_IP/ (certificado autofirmado)"
          echo ""
          echo "üìù Para usar un dominio real con HTTPS v√°lido:"
          echo "   1. Apunta tu dominio al IP: $PUBLIC_IP"
          echo "   2. Instala certbot: sudo apt-get install certbot python3-certbot-nginx"
          echo "   3. Obt√©n certificado: sudo certbot --nginx -d tu-dominio.com"
          echo ""
          echo "üìä Estado final de PM2:"
          pm2 list
          echo ""
          echo "üîç Para ver logs en tiempo real:"
          echo "   pm2 logs flask-app-${{ matrix.instance }}"
          echo ""
          echo "üîÑ Para reiniciar la aplicaci√≥n:"
          echo "   pm2 restart flask-app-${{ matrix.instance }}"
        ENDSSH
        
        # Limpiar archivos temporales
        rm -f deploy_key temp_env_file
        
        echo "‚úÖ Script de despliegue finalizado para instancia ${{ matrix.instance }}"