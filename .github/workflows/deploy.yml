name: Deploy Flask App to EC2 Instances

on:
  push:
    branches: 
      - main
      - oliver-branch
      - alan-branch
      - sebastian-branch
      - hernando-branch
    paths:
      - 'Proyecto_1_Diseno/**'
      - '.github/workflows/deploy.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        # ConfiguraciÃ³n dinÃ¡mica basada en la rama
        include:
          - branch: main
            instances: [1, 2, 3, 4]  # Despliega a todas las instancias
          - branch: oliver-branch
            instances: [1]  # Solo instancia de Oliver
          - branch: alan-branch
            instances: [2]  # Solo instancia de Alan
          - branch: sebastian-branch
            instances: [3]  # Solo instancia de Sebastian
          - branch: hernando-branch
            instances: [4]  # Solo instancia de Hernando

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Determine deployment target
      id: deployment
      run: |
        BRANCH_NAME="${{ github.ref_name }}"
        echo "Branch: $BRANCH_NAME"
        
        # Determinar quÃ© instancias desplegar basado en la rama
        if [ "$BRANCH_NAME" = "main" ]; then
          echo "deploy_to_production=true" >> $GITHUB_OUTPUT
          echo "deploy_to_test=false" >> $GITHUB_OUTPUT
          echo "instances=1,2,3,4" >> $GITHUB_OUTPUT
        elif [[ "$BRANCH_NAME" == *"-branch" ]]; then
          # Extraer el nombre de la rama personal y convertir a minÃºsculas
          PERSON_NAME=$(echo "${BRANCH_NAME%-branch}" | tr '[:upper:]' '[:lower:]')
          echo "deploy_to_production=false" >> $GITHUB_OUTPUT
          echo "deploy_to_test=true" >> $GITHUB_OUTPUT
          echo "person_name=$PERSON_NAME" >> $GITHUB_OUTPUT
          
          # Mapear persona a instancia
          case "$PERSON_NAME" in
            oliver) echo "instances=1" >> $GITHUB_OUTPUT ;;
            alan) echo "instances=2" >> $GITHUB_OUTPUT ;;
            sebastian) echo "instances=3" >> $GITHUB_OUTPUT ;;
            hernando) echo "instances=4" >> $GITHUB_OUTPUT ;;
          esac
        fi

    - name: Deploy to EC2 Instance
      if: contains(fromJson(format('[{0}]', steps.deployment.outputs.instances)), matrix.instances[0])
      env:
        HOST: ${{ secrets[format('EC2_HOST_{0}', matrix.instances[0])] }}
        USER: ${{ secrets[format('EC2_USER_{0}', matrix.instances[0])] }}
        KEY: ${{ secrets[format('EC2_SSH_KEY_{0}', matrix.instances[0])] }}
        ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', matrix.instances[0])] }}
        DOMAIN_BASE: tumaquinaya.com
        BRANCH_NAME: ${{ github.ref_name }}
        IS_PRODUCTION: ${{ steps.deployment.outputs.deploy_to_production }}
        IS_TEST: ${{ steps.deployment.outputs.deploy_to_test }}
      run: |
        echo "ðŸš€ Iniciando despliegue en la instancia ${{ matrix.instances[0] }} desde rama $BRANCH_NAME..."
        
        # Crear el archivo de llave SSH
        echo "$KEY" > deploy_key
        chmod 600 deploy_key
        
        # Crear archivo .env temporal
        echo "$ENV_FILE" > temp_env_file
        
        # Extraer el NAME del archivo .env
        NAME_VALUE=$(grep "^NAME=" temp_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | tr '[:upper:]' '[:lower:]' | xargs)
        
        if [ -z "$NAME_VALUE" ]; then
            NAME_VALUE="instance-${{ matrix.instances[0] }}"
        fi
        
        FULL_DOMAIN="${NAME_VALUE}.${DOMAIN_BASE}"
        
        echo "ðŸ“‹ ConfiguraciÃ³n:"
        echo "   - Rama: ${BRANCH_NAME}"
        echo "   - Tipo de despliegue: $([ "$IS_PRODUCTION" = "true" ] && echo "PRODUCCIÃ“N" || echo "TEST")"
        echo "   - Dominio: ${FULL_DOMAIN}"
        
        # Script remoto actualizado para manejar mÃºltiples ramas
        cat > deploy_remote.sh << 'DEPLOYEOF'
        #!/bin/bash
        set -e

        SUBDOMAIN="${1}"
        DOMAIN_BASE="${2}"
        INSTANCE_NUM="${3}"
        BRANCH_NAME="${4}"
        IS_PRODUCTION="${5}"
        IS_TEST="${6}"

        echo "ðŸ”§ ConfiguraciÃ³n de despliegue:"
        echo "   - Rama: ${BRANCH_NAME}"
        echo "   - ProducciÃ³n: ${IS_PRODUCTION}"
        echo "   - Test: ${IS_TEST}"
        echo "   - Subdominio: ${SUBDOMAIN}"

        # Determinar rutas segÃºn el tipo de despliegue
        if [ "$IS_PRODUCTION" = "true" ]; then
          PROJECT_BASE="/opt/location-tracker"
          APP_NAME="flask-app-${SUBDOMAIN}"
        else
          PROJECT_BASE="/opt/location-tracker-test"
          APP_NAME="flask-app-test-${SUBDOMAIN}"
        fi

        # Crear directorios si no existen
        sudo mkdir -p "$PROJECT_BASE"
        sudo chown $USER:$USER "$PROJECT_BASE"
        cd "$PROJECT_BASE"

        # Clonar o actualizar el repositorio con la rama correcta
        if [ -d .git ]; then
          echo "ðŸ“¦ Actualizando cÃ³digo desde rama ${BRANCH_NAME}..."
          # Fix para el error de referencias de Git
          git remote prune origin
          git fetch origin "${BRANCH_NAME}" --force
          git checkout "${BRANCH_NAME}" || git checkout -B "${BRANCH_NAME}" "origin/${BRANCH_NAME}"
          git reset --hard "origin/${BRANCH_NAME}"
        else
          echo "ðŸ“¥ Clonando repositorio (rama ${BRANCH_NAME})..."
          git clone -b "${BRANCH_NAME}" https://github.com/Diseno2025-30/Geolocation.git .
        fi

        cd Proyecto_1_Diseno
        PROJECT_PATH=$(pwd)

        # Configurar entorno virtual Python
        if [ ! -d "venv" ]; then
          python3 -m venv venv
        fi

        source venv/bin/activate
        pip install --upgrade pip
        pip install flask psycopg2-binary python-dotenv

        if [ -f requirements.txt ]; then
          pip install -r requirements.txt
        fi

        # Crear script de inicio personalizado
        if [ "$IS_TEST" = "true" ]; then
          # Script para la versiÃ³n de test (puerto 5001)
          cat > start_app_test.sh << 'STARTSCRIPT'
        #!/bin/bash
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        cd "$SCRIPT_DIR"
        source venv/bin/activate
        export FLASK_APP=udp_flask_server.py
        export FLASK_ENV=development
        export FLASK_TEST_MODE=true
        python udp_flask_server.py --port 5001
        STARTSCRIPT
          chmod +x start_app_test.sh
          START_SCRIPT="start_app_test.sh"
          PORT="5001"
        else
          # Script para producciÃ³n (puerto 5000)
          cat > start_app.sh << 'STARTSCRIPT'
        #!/bin/bash
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        cd "$SCRIPT_DIR"
        source venv/bin/activate
        export FLASK_APP=udp_flask_server.py
        export FLASK_ENV=production
        python udp_flask_server.py --port 5000
        STARTSCRIPT
          chmod +x start_app.sh
          START_SCRIPT="start_app.sh"
          PORT="5000"
        fi

        # Configurar Nginx con ambas rutas
        echo "ðŸŒ Configurando Nginx..."
        
        # Si es producciÃ³n, actualiza la configuraciÃ³n principal
        if [ "$IS_PRODUCTION" = "true" ]; then
          cat > /tmp/nginx-main << NGINXCONF
        server {
            listen 80;
            server_name ${FULL_DOMAIN} www.${FULL_DOMAIN};
            
            location /.well-known/acme-challenge/ {
                root /var/www/certbot;
            }
            
            # Ruta principal - ProducciÃ³n
            location / {
                proxy_pass http://localhost:5000;
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
            }
            
            # Ruta de test - Solo si existe la app de test
            location /test {
                # Verificar si el servicio de test estÃ¡ activo
                proxy_pass http://localhost:5001/;
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                
                # Reescribir URLs para que funcione correctamente
                proxy_redirect / /test/;
                sub_filter 'href="/' 'href="/test/';
                sub_filter 'src="/' 'src="/test/';
                sub_filter 'action="/' 'action="/test/';
                sub_filter_once off;
            }
            
            # Rutas adicionales para test
            location ~ ^/test/(.*) {
                proxy_pass http://localhost:5001/\$1;
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
            }
        }
        NGINXCONF
          
          sudo mv /tmp/nginx-main /etc/nginx/sites-available/location-tracker
          sudo nginx -t && sudo systemctl reload nginx
        fi

        # Gestionar aplicaciÃ³n con PM2
        echo "ðŸš€ Gestionando aplicaciÃ³n con PM2..."
        
        # Detener y eliminar aplicaciÃ³n anterior si existe
        pm2 stop "${APP_NAME}" 2>/dev/null || true
        pm2 delete "${APP_NAME}" 2>/dev/null || true

        # Iniciar nueva aplicaciÃ³n
        pm2 start "${START_SCRIPT}" \
          --name "${APP_NAME}" \
          --interpreter bash \
          --cwd "$PROJECT_PATH" \
          --log-date-format "YYYY-MM-DD HH:mm:ss"

        pm2 save

        echo ""
        echo "========================================="
        echo "âœ… DESPLIEGUE COMPLETADO"
        echo "========================================="
        echo "ðŸ“Š InformaciÃ³n del despliegue:"
        echo "   - Rama: ${BRANCH_NAME}"
        echo "   - Tipo: $([ "$IS_PRODUCTION" = "true" ] && echo "PRODUCCIÃ“N" || echo "TEST")"
        echo "   - AplicaciÃ³n: ${APP_NAME}"
        echo "   - Puerto: ${PORT}"
        echo "   - Ruta: ${PROJECT_PATH}"
        echo ""
        if [ "$IS_PRODUCTION" = "true" ]; then
          echo "ðŸ”— URLs:"
          echo "   - ProducciÃ³n: https://${FULL_DOMAIN}/"
          echo "   - Test: https://${FULL_DOMAIN}/test"
        else
          echo "ðŸ”— URL de test:"
          echo "   - https://${FULL_DOMAIN}/test"
        fi
        echo "========================================="
        DEPLOYEOF
        
        # Transferir archivos y ejecutar
        scp -o StrictHostKeyChecking=no -i deploy_key temp_env_file ${USER}@${HOST}:/tmp/.env
        scp -o StrictHostKeyChecking=no -i deploy_key deploy_remote.sh ${USER}@${HOST}:/tmp/deploy_remote.sh
        
        ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} \
          "chmod +x /tmp/deploy_remote.sh && \
           /tmp/deploy_remote.sh '${NAME_VALUE}' '${DOMAIN_BASE}' '${{ matrix.instances[0] }}' '${BRANCH_NAME}' '${IS_PRODUCTION}' '${IS_TEST}' && \
           rm /tmp/deploy_remote.sh /tmp/.env"
        
        rm -f deploy_key temp_env_file deploy_remote.sh
        
        echo "âœ… Despliegue completado"