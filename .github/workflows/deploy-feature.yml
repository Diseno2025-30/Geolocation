name: Deploy Feature Branch to Test

on:
  push:
    branches:
      - Oliver-branch
      - Hernando-branch
      - Alan-branch
      - Sebastian-branch
  workflow_dispatch:
    inputs:
      branch:
        description: "Feature branch to deploy"
        required: true
        type: choice
        options:
          - Oliver-branch
          - Hernando-branch
          - Alan-branch
          - Sebastian-branch

jobs:
  deploy-feature:
    runs-on: ubuntu-latest
    
    steps:
    - name: Determine target instance
      id: determine-instance
      run: |
        # Determinar la rama actual
        if [ "${{ github.event_name }}" = "push" ]; then
          BRANCH_NAME="${{ github.ref_name }}"
        else
          BRANCH_NAME="${{ github.event.inputs.branch }}"
        fi
        
        echo "Branch to deploy: ${BRANCH_NAME}"
        
        # Mapear rama a instancia
        case "${BRANCH_NAME}" in
          "Oliver-branch")
            INSTANCE_NUM=1
            PERSON_NAME="Oliver"
            ;;
          "Hernando-branch")
            INSTANCE_NUM=2
            PERSON_NAME="Hernando"
            ;;
          "Alan-branch")
            INSTANCE_NUM=3
            PERSON_NAME="Alan"
            ;;
          "Sebastian-branch")
            INSTANCE_NUM=4
            PERSON_NAME="Sebastian"
            ;;
          *)
            echo "‚ùå Rama no reconocida: ${BRANCH_NAME}"
            exit 1
            ;;
        esac
        
        echo "TARGET_INSTANCE=${INSTANCE_NUM}" >> $GITHUB_OUTPUT
        echo "BRANCH_NAME=${BRANCH_NAME}" >> $GITHUB_OUTPUT
        echo "PERSON_NAME=${PERSON_NAME}" >> $GITHUB_OUTPUT
        
        echo "‚úÖ Desplegando ${BRANCH_NAME} a instancia ${INSTANCE_NUM} (${PERSON_NAME})"

    - name: Checkout branch
      uses: actions/checkout@v3
      with:
        ref: ${{ steps.determine-instance.outputs.BRANCH_NAME }}

    - name: Deploy to assigned instance
      env:
        HOST: ${{ secrets[format('EC2_HOST_{0}', steps.determine-instance.outputs.TARGET_INSTANCE)] }}
        USER: ${{ secrets[format('EC2_USER_{0}', steps.determine-instance.outputs.TARGET_INSTANCE)] }}
        KEY: ${{ secrets[format('EC2_SSH_KEY_{0}', steps.determine-instance.outputs.TARGET_INSTANCE)] }}
        ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', steps.determine-instance.outputs.TARGET_INSTANCE)] }}
        DOMAIN_BASE: tumaquinaya.com
        BRANCH_NAME: ${{ steps.determine-instance.outputs.BRANCH_NAME }}
        PERSON_NAME: ${{ steps.determine-instance.outputs.PERSON_NAME }}
        INSTANCE_NUM: ${{ steps.determine-instance.outputs.TARGET_INSTANCE }}
      run: |
        echo "üöÄ Desplegando ${BRANCH_NAME} en instancia ${INSTANCE_NUM} (${PERSON_NAME}.${DOMAIN_BASE})"
        
        # Crear archivo de llave SSH
        echo "$KEY" > deploy_key
        chmod 600 deploy_key
        
        # Crear archivo .env temporal
        echo "$ENV_FILE" > temp_env_file
        
        # Verificar que el NAME coincida con la persona asignada
        NAME_VALUE=$(grep "^NAME=" temp_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | xargs)
        NAME_LOWER=$(echo "$NAME_VALUE" | tr '[:upper:]' '[:lower:]')
        PERSON_LOWER=$(echo "$PERSON_NAME" | tr '[:upper:]' '[:lower:]')
        
        if [ "${NAME_LOWER}" != "${PERSON_LOWER}" ]; then
            echo "‚ö†Ô∏è ADVERTENCIA: El NAME en .env (${NAME_VALUE}) no coincide con la persona asignada (${PERSON_NAME})"
            echo "   Esto puede causar inconsistencias. Verificar configuraci√≥n."
        fi
        
        FULL_DOMAIN="${NAME_LOWER}.${DOMAIN_BASE}"
        
        echo "üìã Configuraci√≥n:"
        echo "   - Rama: ${BRANCH_NAME}"
        echo "   - Persona: ${PERSON_NAME}"
        echo "   - Instancia: ${INSTANCE_NUM}"
        echo "   - Dominio: ${FULL_DOMAIN}"
        echo "   - URL de test: https://${FULL_DOMAIN}/test"
        
        # ========== SCRIPT OSRM - PUERTO DE BARRANQUILLA ==========
        cat > setup_osrm.sh << 'OSRMEOF'
        #!/bin/bash
        set -e
        
        echo "üó∫Ô∏è ========================================="
        echo "üó∫Ô∏è CONFIGURANDO OSRM - PUERTO DE BARRANQUILLA"
        echo "üó∫Ô∏è ========================================="
        
        # Verificar si OSRM ya est√° instalado y corriendo
        if docker ps 2>/dev/null | grep -q osrm-backend; then
          echo "‚úÖ OSRM ya est√° corriendo correctamente"
          docker ps | grep osrm-backend
          echo ""
          echo "üß™ Probando conectividad OSRM..."
          if curl -s -f http://localhost:5001/nearest/v1/driving/-74.8,10.98 > /dev/null 2>&1; then
            echo "‚úÖ OSRM responde correctamente"
          else
            echo "‚ö†Ô∏è OSRM no responde, reiniciando..."
            docker restart osrm-backend
            sleep 5
          fi
          exit 0
        fi
        
        echo "üì¶ Instalando dependencias..."
        
        # Instalar Docker si no est√° instalado
        if ! command -v docker &> /dev/null; then
          echo "üê≥ Instalando Docker..."
          sudo apt-get update -qq
          sudo apt-get install -y docker.io
          sudo systemctl start docker
          sudo systemctl enable docker
          echo "‚úÖ Docker instalado"
        else
          echo "‚úÖ Docker ya est√° instalado"
        fi
        
        # Instalar osmium-tool para convertir formatos
        if ! command -v osmium &> /dev/null; then
          echo "üîß Instalando osmium-tool..."
          sudo apt-get update -qq
          sudo apt-get install -y osmium-tool
          echo "‚úÖ osmium-tool instalado"
        else
          echo "‚úÖ osmium-tool ya est√° instalado"
        fi
        
        # ========== PERMISOS DE DOCKER ==========
        echo "üîß Configurando permisos de Docker..."
        
        if ! groups $USER | grep -q docker; then
          echo "   Agregando usuario '$USER' al grupo docker..."
          sudo usermod -aG docker $USER
        else
          echo "   Usuario '$USER' ya est√° en el grupo docker"
        fi
        
        echo "   Reiniciando Docker daemon..."
        sudo systemctl restart docker
        sleep 2
        
        sudo chmod 666 /var/run/docker.sock
        echo "‚úÖ Permisos de Docker configurados"
        # =========================================
        
        # Crear directorio para datos OSRM
        OSRM_DIR="/opt/osrm-data"
        echo "üìÅ Creando directorio: ${OSRM_DIR}"
        sudo mkdir -p ${OSRM_DIR}
        sudo chown $USER:$USER ${OSRM_DIR}
        cd ${OSRM_DIR}
        
        # Verificar si el mapa del puerto ya est√° procesado
        if [ -f "puerto-barranquilla.osrm" ]; then
          echo "‚úÖ Mapa del puerto ya procesado, saltando descarga"
        else
          echo ""
          echo "üì• ========================================="
          echo "üì• DESCARGANDO MAPA DEL PUERTO"
          echo "üì• ========================================="
          echo ""
          echo "üó∫Ô∏è M√©todo: Overpass API con IDs espec√≠ficos"
          echo "   √Årea: Puerto de Barranquilla"
          echo "   Calles: ~75 v√≠as espec√≠ficas"
          echo "   Nodos: 6 nodos clave"
          echo "   Fuente: OpenStreetMap"
          echo ""
          
          # Limpiar descargas previas
          rm -f puerto-barranquilla.osm puerto-barranquilla.osm.pbf
          
          # Descargar usando Overpass API con los IDs exactos del puerto
          MAX_ATTEMPTS=5
          ATTEMPT=1

          echo "üåê Descargando desde Overpass API..."
          echo "   (Esto deber√≠a tardar 10-20 segundos)"
          echo ""

          # Query optimizada con los IDs exactos de las calles del puerto
          OVERPASS_QUERY='[out:xml][timeout:90];(way(id:110447827,962055972,183530006,100301189,250255381,1007963947,99509101,1211032219,1211032217,1211032218,1211032224,1211032225,1211032220,1141049217,1007248971,1007248970,100301186,613384233,1005153829,613384205,613384208,613384207,613384206,1006086573,1006126955,613384225,613384224,613384223,613384222,613384221,1006086571,1006086572,1006039189,613384220,1006039191,1007626213,1006039190,613384218,613384217,626724241,626724245,626724242,613384231,613384216,613384219,613384226,1006042462,613384227,613384228,613384204,1006042461,1007581441,1006039193,1006039192,1006042459,1007537492,1057537489,1007603926,1007603925,1211032216,1006062382,1006062385,1006062384,1006062383,1006062386,626724235,626724233,626724238,1007538907,1007538908,962055977,962055976,613384209);node(id:6402440891,1939277496,8899212525,1939277480,9282142137,9295853166););(._;>;);out body;'

          echo "$OVERPASS_QUERY" > /tmp/overpass_query.txt
          
          MAX_ATTEMPTS=5
          ATTEMPT=1

          until curl -L --connect-timeout 60 --max-time 120 \
            --retry 3 --retry-delay 5 \
            -d @/tmp/overpass_query.txt \
            "https://overpass-api.de/api/interpreter" \
            -o puerto-barranquilla.osm; do
            
            if [ $ATTEMPT -ge $MAX_ATTEMPTS ]; then
              echo ""
              echo "‚ùå Error: No se pudo descargar desde Overpass API"
              exit 1
            fi
            
            echo ""
            echo "‚ö†Ô∏è Intento $ATTEMPT de $MAX_ATTEMPTS fall√≥"
            echo "   Esperando 15 segundos antes de reintentar..."
            ATTEMPT=$((ATTEMPT+1))
            sleep 15
            rm -f puerto-barranquilla.osm
          done

          echo ""
          echo "‚úÖ Descarga completada desde Overpass API"
          FILE_SIZE=$(stat -c%s puerto-barranquilla.osm 2>/dev/null || stat -f%z puerto-barranquilla.osm)

          if [ $FILE_SIZE -lt 10000 ]; then
            echo "‚ö†Ô∏è Archivo muy peque√±o ($FILE_SIZE bytes)"
            
            # Intentar descomprimir si est√° en gzip
            if file puerto-barranquilla.osm | grep -q "gzip"; then
              echo "üì¶ Archivo comprimido, descomprimiendo..."
              mv puerto-barranquilla.osm puerto-barranquilla.osm.gz
              gunzip puerto-barranquilla.osm.gz
            fi
            
            echo "üìÑ Contenido del archivo:"
            head -50 puerto-barranquilla.osm
            echo ""
            exit 1
          fi
          
          echo "   Archivo: $(ls -lh puerto-barranquilla.osm | awk '{print $5}')"
          
          # ========== CONVERTIR DE OSM (XML) A OSM.PBF (BINARIO) ==========
          echo ""
          echo "üîÑ ========================================="
          echo "üîÑ CONVIRTIENDO FORMATO"
          echo "üîÑ ========================================="
          echo ""
          echo "   De: OSM (XML sin comprimir)"
          echo "   A:  OSM.PBF (binario comprimido)"
          echo "   Raz√≥n: OSRM requiere formato PBF"
          echo ""
          
          if ! osmium cat puerto-barranquilla.osm -o puerto-barranquilla.osm.pbf --overwrite; then
            echo "‚ùå Error convirtiendo formato OSM a PBF"
            exit 1
          fi
          
          echo "‚úÖ Conversi√≥n completada"
          echo "   Archivo OSM original: $(ls -lh puerto-barranquilla.osm 2>/dev/null | awk '{print $5}')"
          echo "   Archivo PBF comprimido: $(ls -lh puerto-barranquilla.osm.pbf | awk '{print $5}')"
          echo ""
          
          # Limpiar archivo XML
          echo "üßπ Limpiando archivo OSM original..."
          rm -f puerto-barranquilla.osm
          echo "üíæ Archivo final: $(ls -lh puerto-barranquilla.osm.pbf | awk '{print $5}')"
          
          # ========== PROCESAR CON OSRM ==========
          echo ""
          echo "‚öôÔ∏è ========================================="
          echo "‚öôÔ∏è PROCESANDO MAPA CON OSRM"
          echo "‚öôÔ∏è ========================================="
          echo ""
          echo "   Algoritmo: MLD (Multi-Level Dijkstra)"
          echo "   Perfil: Car (autom√≥viles)"
          echo "   Tiempo estimado: 10-20 segundos"
          echo ""
          
          echo "üìç Paso 1/3: Extracci√≥n de datos de rutas..."
          if ! docker run -t -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend \
            osrm-extract -p /opt/car.lua /data/puerto-barranquilla.osm.pbf; then
            echo "‚ùå Error en extracci√≥n OSRM"
            echo "üí° Verifica los logs arriba para m√°s detalles"
            exit 1
          fi
          echo "‚úÖ Extracci√≥n completada"
          
          echo ""
          echo "üóÇÔ∏è Paso 2/3: Particionamiento de grafo..."
          if ! docker run -t -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend \
            osrm-partition /data/puerto-barranquilla.osrm; then
            echo "‚ùå Error en particionamiento OSRM"
            exit 1
          fi
          echo "‚úÖ Particionamiento completado"
          
          echo ""
          echo "üé® Paso 3/3: Personalizaci√≥n de rutas..."
          if ! docker run -t -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend \
            osrm-customize /data/puerto-barranquilla.osrm; then
            echo "‚ùå Error en personalizaci√≥n OSRM"
            exit 1
          fi
          echo "‚úÖ Personalizaci√≥n completada"
          
          echo ""
          echo "‚úÖ Procesamiento OSRM completado exitosamente"
          
          # Limpiar archivo .osm.pbf para ahorrar espacio
          echo ""
          echo "üßπ Limpiando archivos temporales..."
          rm -f puerto-barranquilla.osm.pbf
          
          echo ""
          echo "üíæ Espacio utilizado:"
          du -sh ${OSRM_DIR}
          echo ""
          echo "üìÇ Archivos finales:"
          ls -lh ${OSRM_DIR}/ | grep puerto-barranquilla
        fi
        
        echo ""
        echo "üöÄ ========================================="
        echo "üöÄ INICIANDO SERVIDOR OSRM"
        echo "üöÄ ========================================="
        
        # Detener contenedor anterior si existe
        docker stop osrm-backend 2>/dev/null || true
        docker rm osrm-backend 2>/dev/null || true
        
        # Iniciar servidor OSRM en puerto 5001
        echo "   Puerto: 5001"
        echo "   Algoritmo: MLD"
        echo "   Auto-reinicio: Habilitado"
        echo ""
        
        docker run -d --name osrm-backend \
          --restart unless-stopped \
          -p 5001:5000 \
          -v "${PWD}:/data" \
          ghcr.io/project-osrm/osrm-backend \
          osrm-routed --algorithm mld /data/puerto-barranquilla.osrm
        
        # Esperar a que OSRM est√© listo
        echo "‚è≥ Esperando que OSRM est√© listo..."
        for i in {1..30}; do
          if curl -s -f http://localhost:5001/nearest/v1/driving/-74.8,10.98 > /dev/null 2>&1; then
            echo ""
            echo "‚úÖ OSRM est√° funcionando correctamente"
            break
          fi
          if [ $i -eq 30 ]; then
            echo ""
            echo "‚ùå Timeout esperando OSRM. Ver logs:"
            docker logs osrm-backend --tail 50
            exit 1
          fi
          echo -n "."
          sleep 2
        done
        
        echo ""
        echo "üîß Configurando servicio systemd para auto-inicio..."
        
        # Crear servicio systemd
        sudo tee /etc/systemd/system/osrm.service > /dev/null << SERVICEEOF
        [Unit]
        Description=OSRM Backend Service - Puerto de Barranquilla
        After=docker.service
        Requires=docker.service
        
        [Service]
        Type=simple
        User=$USER
        Restart=always
        RestartSec=10
        ExecStartPre=-/usr/bin/docker stop osrm-backend
        ExecStartPre=-/usr/bin/docker rm osrm-backend
        ExecStart=/usr/bin/docker run --rm --name osrm-backend -p 5001:5000 -v ${OSRM_DIR}:/data ghcr.io/project-osrm/osrm-backend osrm-routed --algorithm mld /data/puerto-barranquilla.osrm
        ExecStop=/usr/bin/docker stop osrm-backend
        
        [Install]
        WantedBy=multi-user.target
        SERVICEEOF
        
        sudo systemctl daemon-reload
        sudo systemctl enable osrm
        
        echo "‚úÖ Servicio systemd configurado"
        
        # Prueba final
        echo ""
        echo "üß™ ========================================="
        echo "üß™ PRUEBA DE SNAP-TO-ROADS"
        echo "üß™ ========================================="
        echo ""
        
        RESPONSE=$(curl -s http://localhost:5001/nearest/v1/driving/-74.8,10.98)
        if echo "$RESPONSE" | grep -q "Ok"; then
          echo "‚úÖ Snap-to-roads funcionando correctamente"
          echo ""
          echo "üìç Prueba realizada:"
          echo "   Coordenada original: (-74.8, 10.98)"
          echo "   Ubicaci√≥n: Puerto de Barranquilla"
          echo "   Resultado: Ajustada a la calle m√°s cercana del puerto"
        else
          echo "‚ö†Ô∏è Respuesta inesperada de OSRM:"
          echo "$RESPONSE"
        fi
        
        echo ""
        echo "========================================="
        echo "‚úÖ INSTALACI√ìN COMPLETADA"
        echo "========================================="
        echo ""
        echo "üìä INFORMACI√ìN DEL SISTEMA:"
        echo "   - URL local: http://localhost:5001"
        echo "   - Directorio: ${OSRM_DIR}"
        echo "   - Mapa: Puerto de Barranquilla"
        echo "   - Calles: ~75 v√≠as espec√≠ficas"
        echo "   - Fuente: OpenStreetMap (IDs espec√≠ficos)"
        echo "   - Algoritmo: MLD (Multi-Level Dijkstra)"
        echo "   - Espacio usado: $(du -sh ${OSRM_DIR} | cut -f1)"
        echo ""
        echo "üó∫Ô∏è COBERTURA:"
        echo "   ‚úÖ Carrera 30"
        echo "   ‚úÖ Calle 1F, Calle 2, Calle 4"
        echo "   ‚úÖ Carrera 38"
        echo "   ‚úÖ V√≠as internas del puerto (~70 calles)"
        echo "   ‚úÖ 6 nodos clave de intersecci√≥n"
        echo ""
        echo "üß™ COMANDOS DE PRUEBA:"
        echo "   # Snap-to-roads en el puerto"
        echo "   curl 'http://localhost:5001/nearest/v1/driving/-74.8,10.98'"
        echo ""
        echo "   # Ruta dentro del puerto"
        echo "   curl 'http://localhost:5001/route/v1/driving/-74.8,10.98;-74.79,10.97'"
        echo ""
        echo "   # Match (ajustar trayectoria GPS)"
        echo "   curl 'http://localhost:5001/match/v1/driving/-74.8,10.98;-74.795,10.975;-74.79,10.97'"
        echo ""
        echo "üõ†Ô∏è COMANDOS √öTILES:"
        echo "   docker logs -f osrm-backend     # Ver logs en tiempo real"
        echo "   docker restart osrm-backend     # Reiniciar servidor"
        echo "   systemctl status osrm           # Estado del servicio"
        echo "   docker stats osrm-backend       # Monitorear recursos"
        echo ""
        echo "üìö DOCUMENTACI√ìN:"
        echo "   API OSRM: https://project-osrm.org/docs/v5.24.0/api/"
        echo "========================================="
        OSRMEOF
        # ========== FIN SCRIPT OSRM ==========
        
        # Crear script de despliegue remoto
        cat > deploy_test_remote.sh << 'DEPLOYEOF'
        #!/bin/bash
        set -e
        
        # Recibir par√°metros
        SUBDOMAIN="${1}"
        DOMAIN_BASE="${2}"
        INSTANCE_NUM="${3}"
        BRANCH_NAME="${4}"
        PERSON_NAME="${5}"
        
        echo "üîß Configuraci√≥n de despliegue /test:"
        echo "   - Rama: ${BRANCH_NAME}"
        echo "   - Persona: ${PERSON_NAME}"
        echo "   - Subdominio: ${SUBDOMAIN}"
        echo "   - Dominio: ${SUBDOMAIN}.${DOMAIN_BASE}"
        echo "   - Instancia: ${INSTANCE_NUM}"
        
        # Determinar ruta base del proyecto
        if [ -d "/home/ubuntu/Web-server-UDP" ]; then
          BASE_DIR="/home/ubuntu/Web-server-UDP"
        else
          BASE_DIR="/opt/location-tracker"
          sudo mkdir -p ${BASE_DIR}
          sudo chown $USER:$USER ${BASE_DIR}
        fi
        
        # Crear directorio para la versi√≥n test
        TEST_DIR="${BASE_DIR}/test"
        mkdir -p "${TEST_DIR}"
        cd "${TEST_DIR}"
        
        echo "üìÅ Directorio de test: ${TEST_DIR}"
        
        # Actualizar o clonar el c√≥digo de la rama
        if [ -d .git ]; then
          echo "üì¶ Actualizando c√≥digo de la rama ${BRANCH_NAME}..."
          git fetch origin ${BRANCH_NAME}
          git checkout ${BRANCH_NAME}
          git reset --hard origin/${BRANCH_NAME}
          CODE_UPDATED=true
        else
          echo "üì• Clonando repositorio en rama ${BRANCH_NAME}..."
          git clone -b ${BRANCH_NAME} https://github.com/Diseno2025-30/Geolocation.git .
          CODE_UPDATED=true
        fi
        
        # Navegar al directorio del proyecto
        cd Proyecto_1_Diseno
        PROJECT_PATH=$(pwd)
        
        # üîí CORRECCI√ìN DE PERMISOS PARA NGINX
        echo "üîí Configurando permisos para que Nginx (www-data) pueda acceder..."
        chmod o+rx ${BASE_DIR}
        chmod o+rx ${TEST_DIR}
        chmod o+rx ${PROJECT_PATH}
        
        # Si existe carpeta static, configurar permisos recursivamente
        if [ -d "static" ]; then
          find static -type d -exec chmod o+rx {} \;
          find static -type f -exec chmod o+r {} \;
          echo "‚úÖ Permisos configurados para carpeta static"
        fi
        
        # Copiar el archivo .env de producci√≥n y modificarlo
        if [ -f "${BASE_DIR}/Proyecto_1_Diseno/.env" ]; then
          cp "${BASE_DIR}/Proyecto_1_Diseno/.env" .env
        fi
        
        # Agregar configuraci√≥n espec√≠fica para test
        echo "" >> .env
        echo "# Configuraci√≥n de test" >> .env
        echo "TEST_MODE=true" >> .env
        echo "BRANCH_NAME=${BRANCH_NAME}" >> .env
        echo "PERSON_NAME=${PERSON_NAME}" >> .env
        
        FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
        APP_NAME="flask-test-${SUBDOMAIN}"
        TEST_PORT=6000
        
        echo "üìä Configuraci√≥n:"
        echo "   - APP_NAME: ${APP_NAME}"
        echo "   - Puerto test: ${TEST_PORT}"
        echo "   - Proyecto: ${PROJECT_PATH}"
        
        # Instalar dependencias
        echo "üì¶ Instalando dependencias..."
        sudo apt-get update -qq
        sudo apt-get install -y python3-pip python3-venv nginx
        
        # PM2 si no est√° instalado
        if ! command -v pm2 &> /dev/null; then
          if ! command -v node &> /dev/null; then
            curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
            sudo apt-get install -y nodejs
          fi
          sudo npm install -g pm2
          pm2 startup systemd -u $USER --hp /home/$USER
        fi
        
        # Configurar entorno virtual de Python
        echo "üêç Configurando entorno Python para test..."
        if [ ! -d "venv" ]; then
          python3 -m venv venv
        fi
        
        source venv/bin/activate
        pip install --upgrade pip
        pip install flask psycopg2-binary python-dotenv requests
        
        if [ -f requirements.txt ]; then
          pip install -r requirements.txt
        fi
        
        # Detener aplicaci√≥n test anterior si existe
        pm2 stop ${APP_NAME} 2>/dev/null || true
        pm2 delete ${APP_NAME} 2>/dev/null || true
        
        # Liberar puerto
        sudo fuser -k ${TEST_PORT}/tcp 2>/dev/null || true
        sleep 2
        
        # Crear script de inicio para test
        cat > start_test_app.sh << STARTSCRIPT
        #!/bin/bash
        cd "\$(dirname "\$0")"
        source venv/bin/activate
        export FLASK_APP=udp_flask_server.py
        export FLASK_ENV=development
        python udp_flask_server.py --port ${TEST_PORT}
        STARTSCRIPT
        chmod +x start_test_app.sh
        
        # Actualizar configuraci√≥n de Nginx para agregar /test
        echo "üåê Configurando Nginx para /test..."
        
        NGINX_CONF="/etc/nginx/sites-available/location-tracker"
        
        # Eliminar configuraciones de test anteriores
        sudo sed -i '/# ===== INICIO RUTAS TEST/,/# ===== FIN RUTAS TEST/d' ${NGINX_CONF}
        
        # Crear archivo temporal con las rutas de test
        cat > /tmp/nginx-test-inject.conf << NGINXTEST
        
        # ===== INICIO RUTAS TEST =====
        # Rama: ${BRANCH_NAME} - Persona: ${PERSON_NAME}
        # Actualizado: $(date)
        
        location = /test {
            return 301 /test/;
        }
        
        location /test/static/ {
            alias ${PROJECT_PATH}/static/;
            add_header Cache-Control "no-cache, no-store, must-revalidate";
            add_header Pragma "no-cache";
            add_header Expires "0";
        }
        
        location /test/ {
            proxy_pass http://localhost:${TEST_PORT}/;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
            proxy_set_header X-Script-Name /test;
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
            proxy_buffering off;
        }
        
        location ~ ^/test/(coordenadas|database|version|health)$ {
            proxy_pass http://localhost:${TEST_PORT}/\$1;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }
        
        # ===== FIN RUTAS TEST =====
        
        NGINXTEST
        
        # Insertar las rutas de test antes de la ubicaci√≥n principal
        sudo awk '
        /location \/ \{/ {
            while ((getline line < "/tmp/nginx-test-inject.conf") > 0)
                print line
            close("/tmp/nginx-test-inject.conf")
        }
        { print }
        ' ${NGINX_CONF} > /tmp/nginx-new.conf
        
        sudo mv /tmp/nginx-new.conf ${NGINX_CONF}
        rm -f /tmp/nginx-test-inject.conf
        
        # Verificar y recargar Nginx
        if sudo nginx -t; then
          sudo systemctl reload nginx
          echo "‚úÖ Nginx configurado para /test"
        else
          echo "‚ùå Error en configuraci√≥n de Nginx"
          sudo nginx -t
          exit 1
        fi
        
        # Iniciar aplicaci√≥n con PM2
        echo "üöÄ Iniciando aplicaci√≥n de test..."
        pm2 start start_test_app.sh \
          --name ${APP_NAME} \
          --interpreter bash \
          --cwd ${PROJECT_PATH} \
          --log-date-format "YYYY-MM-DD HH:mm:ss"
        
        pm2 save
        
        # Esperar y verificar
        echo "‚è≥ Esperando inicio de la aplicaci√≥n..."
        sleep 5
        
        # Verificaci√≥n
        echo "üìä Estado de la aplicaci√≥n:"
        pm2 status ${APP_NAME}
        
        # Test de conectividad
        echo "üß™ Probando aplicaci√≥n..."
        if curl -s -f http://localhost:${TEST_PORT}/ > /dev/null 2>&1; then
          echo "‚úÖ Aplicaci√≥n respondiendo en puerto ${TEST_PORT}"
        else
          echo "‚ö†Ô∏è La aplicaci√≥n no responde"
          pm2 logs ${APP_NAME} --lines 20 --nostream
        fi
        
        # Resumen final
        echo ""
        echo "========================================="
        echo "üéâ AMBIENTE DE TEST DESPLEGADO"
        echo "========================================="
        echo ""
        echo "üìä INFORMACI√ìN:"
        echo "   - Persona: ${PERSON_NAME}"
        echo "   - Rama: ${BRANCH_NAME}"
        echo "   - Instancia EC2: ${INSTANCE_NUM}"
        echo "   - Aplicaci√≥n PM2: ${APP_NAME}"
        echo "   - Puerto interno: ${TEST_PORT}"
        echo "   - OSRM: http://localhost:5001 (Puerto de Barranquilla)"
        echo ""
        echo "üîó URLS:"
        echo "   - Producci√≥n (main): https://${FULL_DOMAIN}/"
        echo "   - Test (${BRANCH_NAME}): https://${FULL_DOMAIN}/test"
        echo ""
        echo "üìç ENDPOINTS DE TEST:"
        echo "   - https://${FULL_DOMAIN}/test/coordenadas"
        echo "   - https://${FULL_DOMAIN}/test/database"
        echo "   - https://${FULL_DOMAIN}/test/version"
        echo "   - https://${FULL_DOMAIN}/test/health"
        echo ""
        echo "üõ†Ô∏è COMANDOS √öTILES:"
        echo "   - Ver logs test: pm2 logs ${APP_NAME}"
        echo "   - Reiniciar test: pm2 restart ${APP_NAME}"
        echo "   - Ver logs prod: pm2 logs flask-app-${SUBDOMAIN}"
        echo "   - Estado: pm2 status"
        echo "   - OSRM logs: docker logs -f osrm-backend"
        echo ""
        echo "üó∫Ô∏è OSRM configurado para Puerto de Barranquilla"
        echo "   M√©todo: Overpass API con IDs espec√≠ficos"
        echo "   Cobertura: ~75 calles del puerto + 6 nodos clave"
        echo "========================================="
        DEPLOYEOF
        
        # Transferir scripts
        echo "üì§ Transfiriendo archivos al servidor..."
        scp -o StrictHostKeyChecking=no -i deploy_key setup_osrm.sh ${USER}@${HOST}:/tmp/
        scp -o StrictHostKeyChecking=no -i deploy_key temp_env_file ${USER}@${HOST}:/tmp/test_env_file
        scp -o StrictHostKeyChecking=no -i deploy_key deploy_test_remote.sh ${USER}@${HOST}:/tmp/
        
        # Ejecutar instalaci√≥n/verificaci√≥n de OSRM PRIMERO
        echo ""
        echo "üó∫Ô∏è ========================================="
        echo "üó∫Ô∏è PASO 1: CONFIGURAR OSRM (PUERTO)"
        echo "üó∫Ô∏è ========================================="
        ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} \
          "chmod +x /tmp/setup_osrm.sh && /tmp/setup_osrm.sh"
        
        # Ejecutar despliegue de la aplicaci√≥n
        echo ""
        echo "üöÄ ========================================="
        echo "üöÄ PASO 2: DESPLEGAR APLICACI√ìN"
        echo "üöÄ ========================================="
        ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} \
          "chmod +x /tmp/deploy_test_remote.sh && \
           /tmp/deploy_test_remote.sh '${NAME_LOWER}' '${DOMAIN_BASE}' '${INSTANCE_NUM}' '${BRANCH_NAME}' '${PERSON_NAME}' && \
           if [ -f /tmp/test_env_file ]; then \
             if [ -d /home/ubuntu/Web-server-UDP/test/Proyecto_1_Diseno ]; then \
               mv /tmp/test_env_file /home/ubuntu/Web-server-UDP/test/Proyecto_1_Diseno/.env; \
             else \
               mv /tmp/test_env_file /opt/location-tracker/test/Proyecto_1_Diseno/.env; \
             fi; \
           fi; \
           rm -f /tmp/deploy_test_remote.sh /tmp/setup_osrm.sh"
        
        # Limpiar archivos temporales locales
        rm -f deploy_key temp_env_file deploy_test_remote.sh setup_osrm.sh
        
        echo ""
        echo "========================================="
        echo "‚úÖ DESPLIEGUE COMPLETADO"
        echo "========================================="
        echo ""
        echo "üéâ ${PERSON_NAME} puede ver sus cambios en:"
        echo "   üì± https://${FULL_DOMAIN}/test"
        echo ""
        echo "üó∫Ô∏è OSRM (Snap-to-Roads) configurado:"
        echo "   ‚úÖ M√©todo: Overpass API"
        echo "   ‚úÖ Fuente: OpenStreetMap (IDs espec√≠ficos)"
        echo "   ‚úÖ √Årea: Puerto de Barranquilla √∫nicamente"
        echo "   ‚úÖ Calles: ~75 v√≠as espec√≠ficas"
        echo "   ‚úÖ Puerto local: 5001"
        echo ""
        echo "üìä Cobertura del mapa:"
        echo "   ‚úÖ Carrera 30, Carrera 38"
        echo "   ‚úÖ Calle 1F, Calle 2, Calle 4"
        echo "   ‚úÖ V√≠as internas del puerto"
        echo "   ‚úÖ 6 nodos clave de intersecci√≥n"
        echo "========================================"