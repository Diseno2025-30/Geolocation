name: Deploy Feature Branch to Test

on:
  workflow_dispatch:
    inputs:
      branch:
        description: "Feature branch to deploy"
        required: true
        type: choice
        options:
          - Oliver-branch
          - Alan-branch
          - Sebastian-branch
          - Hernando-branch
      deploy_to_instance_1:
        description: "Deploy to Instance 1"
        type: boolean
        default: false
      deploy_to_instance_2:
        description: "Deploy to Instance 2"
        type: boolean
        default: false
      deploy_to_instance_3:
        description: "Deploy to Instance 3"
        type: boolean
        default: false
      deploy_to_instance_4:
        description: "Deploy to Instance 4"
        type: boolean
        default: false

jobs:
  deploy-feature:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - instance: 1
            deploy: ${{ github.event.inputs.deploy_to_instance_1 }}
          - instance: 2
            deploy: ${{ github.event.inputs.deploy_to_instance_2 }}
          - instance: 3
            deploy: ${{ github.event.inputs.deploy_to_instance_3 }}
          - instance: 4
            deploy: ${{ github.event.inputs.deploy_to_instance_4 }}

    steps:
    - name: Skip unchecked instances
      if: matrix.deploy != 'true'
      run: echo "Skipping instance ${{ matrix.instance }} for this run"

    - name: Checkout feature branch
      if: matrix.deploy == 'true'
      uses: actions/checkout@v3
      with:
        ref: ${{ github.event.inputs.branch }}

    - name: Deploy Feature Branch to /test
      if: matrix.deploy == 'true'
      env:
        HOST: ${{ secrets[format('EC2_HOST_{0}', matrix.instance)] }}
        USER: ${{ secrets[format('EC2_USER_{0}', matrix.instance)] }}
        KEY: ${{ secrets[format('EC2_SSH_KEY_{0}', matrix.instance)] }}
        ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', matrix.instance)] }}
        DOMAIN_BASE: tumaquinaya.com
        BRANCH_NAME: ${{ github.event.inputs.branch }}
      run: |
        echo "üöÄ Desplegando rama ${BRANCH_NAME} en /test de instancia ${{ matrix.instance }}..."
        
        # Crear archivo de llave SSH
        echo "$KEY" > deploy_key
        chmod 600 deploy_key
        
        # Crear archivo .env temporal
        echo "$ENV_FILE" > temp_env_file
        
        # Extraer el NAME del archivo .env (esto define el subdominio)
        NAME_VALUE=$(grep "^NAME=" temp_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | xargs)
        SUBDOMAIN=$(echo "$NAME_VALUE" | tr '[:upper:]' '[:lower:]')
        
        if [ -z "$SUBDOMAIN" ]; then
            echo "‚ùå No se encontr√≥ NAME en .env"
            exit 1
        fi
        
        # Extraer el nombre base de la rama (Oliver, Alan, etc.)
        PERSON_NAME=$(echo "${BRANCH_NAME}" | cut -d'-' -f1 | tr '[:upper:]' '[:lower:]')
        
        # Verificar que el subdominio corresponde con la rama
        if [ "${SUBDOMAIN}" != "${PERSON_NAME}" ]; then
            echo "‚ö†Ô∏è Advertencia: El subdominio (${SUBDOMAIN}) no coincide con la rama (${PERSON_NAME})"
            echo "   Continuando con el despliegue..."
        fi
        
        FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
        
        echo "üìã Configuraci√≥n detectada:"
        echo "   - Rama: ${BRANCH_NAME}"
        echo "   - Subdominio: ${SUBDOMAIN}"
        echo "   - Dominio completo: ${FULL_DOMAIN}"
        echo "   - URL de test: https://${FULL_DOMAIN}/test"
        
        # Crear script de despliegue remoto
        cat > deploy_test_remote.sh << 'DEPLOYEOF'
        #!/bin/bash
        set -e
        
        # Recibir par√°metros
        SUBDOMAIN="${1}"
        DOMAIN_BASE="${2}"
        INSTANCE_NUM="${3}"
        BRANCH_NAME="${4}"
        
        echo "üîß Configuraci√≥n de despliegue /test:"
        echo "   - Rama: ${BRANCH_NAME}"
        echo "   - Subdominio: ${SUBDOMAIN}"
        echo "   - Dominio: ${SUBDOMAIN}.${DOMAIN_BASE}"
        
        # Determinar ruta base del proyecto
        if [ -d "/home/ubuntu/Web-server-UDP" ]; then
          BASE_DIR="/home/ubuntu/Web-server-UDP"
        else
          BASE_DIR="/opt/location-tracker"
          sudo mkdir -p ${BASE_DIR}
          sudo chown $USER:$USER ${BASE_DIR}
        fi
        
        # Crear directorio para la versi√≥n test
        TEST_DIR="${BASE_DIR}/test"
        mkdir -p "${TEST_DIR}"
        cd "${TEST_DIR}"
        
        echo "üìÅ Directorio de test: ${TEST_DIR}"
        
        # Actualizar o clonar el c√≥digo de la rama
        if [ -d .git ]; then
          echo "üì¶ Actualizando c√≥digo de la rama ${BRANCH_NAME}..."
          git fetch origin ${BRANCH_NAME}
          git checkout ${BRANCH_NAME}
          git reset --hard origin/${BRANCH_NAME}
        else
          echo "üì• Clonando repositorio en rama ${BRANCH_NAME}..."
          git clone -b ${BRANCH_NAME} https://github.com/Diseno2025-30/Geolocation.git .
        fi
        
        # Navegar al directorio del proyecto
        cd Proyecto_1_Diseno
        PROJECT_PATH=$(pwd)
        
        # Copiar el archivo .env de producci√≥n
        if [ -f "${BASE_DIR}/Proyecto_1_Diseno/.env" ]; then
          cp "${BASE_DIR}/Proyecto_1_Diseno/.env" .env
        fi
        
        # Agregar configuraci√≥n espec√≠fica para test
        echo "FLASK_ENV=development" >> .env
        echo "TEST_MODE=true" >> .env
        echo "BRANCH_NAME=${BRANCH_NAME}" >> .env
        
        FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
        APP_NAME="flask-test-${SUBDOMAIN}"
        TEST_PORT=$((6000 + INSTANCE_NUM))  # Puerto diferente para test
        
        echo "üìä Configuraci√≥n:"
        echo "   - APP_NAME: ${APP_NAME}"
        echo "   - Puerto test: ${TEST_PORT}"
        echo "   - Proyecto: ${PROJECT_PATH}"
        
        # Instalar dependencias
        echo "üì¶ Instalando dependencias..."
        sudo apt-get update -qq
        sudo apt-get install -y python3-pip python3-venv nginx
        
        # PM2 si no est√° instalado
        if ! command -v pm2 &> /dev/null; then
          if ! command -v node &> /dev/null; then
            curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
            sudo apt-get install -y nodejs
          fi
          sudo npm install -g pm2
          pm2 startup systemd -u $USER --hp /home/$USER
        fi
        
        # Configurar entorno virtual de Python
        echo "üêç Configurando entorno Python para test..."
        if [ ! -d "venv" ]; then
          python3 -m venv venv
        fi
        
        source venv/bin/activate
        pip install --upgrade pip
        pip install flask psycopg2-binary python-dotenv
        
        if [ -f requirements.txt ]; then
          pip install -r requirements.txt
        fi
        
        # Detener aplicaci√≥n test anterior si existe
        pm2 stop ${APP_NAME} 2>/dev/null || true
        pm2 delete ${APP_NAME} 2>/dev/null || true
        
        # Liberar puerto
        sudo fuser -k ${TEST_PORT}/tcp 2>/dev/null || true
        sleep 2
        
        # Crear script de inicio para test
        cat > start_test_app.sh << STARTSCRIPT
        #!/bin/bash
        cd "\$(dirname "\$0")"
        source venv/bin/activate
        export FLASK_APP=udp_flask_server.py
        export FLASK_ENV=development
        export TEST_MODE=true
        python udp_flask_server.py --port ${TEST_PORT}
        STARTSCRIPT
        chmod +x start_test_app.sh
        
        # Actualizar configuraci√≥n de Nginx para agregar /test
        echo "üåê Configurando Nginx para /test..."
        
        # Buscar el archivo de configuraci√≥n del sitio
        NGINX_CONF="/etc/nginx/sites-available/location-tracker"
        
        # Crear un archivo temporal con las rutas /test
        cat > /tmp/nginx-test-routes.conf << NGINXTEST
        
        # ===== RUTAS DE TEST (rama: ${BRANCH_NAME}) =====
        
        # Ruta principal de test
        location /test {
            proxy_pass http://localhost:${TEST_PORT}/;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
            proxy_buffering off;
        }
        
        location /test/ {
            proxy_pass http://localhost:${TEST_PORT}/;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }
        
        # API endpoints de test
        location ~ ^/test/(coordenadas|database|version|health) {
            proxy_pass http://localhost:${TEST_PORT}/\$1;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }
        
        # Archivos est√°ticos de test
        location /test/static {
            alias ${PROJECT_PATH}/static;
            expires 30d;
            add_header Cache-Control "public, immutable";
        }
        
        # ===== FIN RUTAS DE TEST =====
        NGINXTEST
        
        # Incluir las rutas de test en la configuraci√≥n principal
        # Primero, eliminar configuraciones de test anteriores si existen
        sudo sed -i '/# ===== RUTAS DE TEST/,/# ===== FIN RUTAS DE TEST =====/d' ${NGINX_CONF}
        
        # Ahora insertar las nuevas rutas de test dentro del bloque server HTTPS
        # Buscar la l√≠nea "location / {" y agregar las rutas de test antes
        sudo sed -i "/location \/ {/r /tmp/nginx-test-routes.conf" ${NGINX_CONF}
        
        # Verificar y recargar Nginx
        if sudo nginx -t; then
          sudo systemctl reload nginx
          echo "‚úÖ Nginx configurado para /test"
        else
          echo "‚ùå Error en configuraci√≥n de Nginx"
          sudo nginx -t
          exit 1
        fi
        
        # Iniciar aplicaci√≥n con PM2
        echo "üöÄ Iniciando aplicaci√≥n de test..."
        pm2 start start_test_app.sh \
          --name ${APP_NAME} \
          --interpreter bash \
          --cwd ${PROJECT_PATH} \
          --log-date-format "YYYY-MM-DD HH:mm:ss"
        
        pm2 save
        
        # Esperar y verificar
        echo "‚è≥ Esperando inicio de la aplicaci√≥n..."
        sleep 5
        
        # Verificaci√≥n
        echo "üìä Estado de la aplicaci√≥n:"
        pm2 status ${APP_NAME}
        
        # Test de conectividad
        echo "üß™ Probando aplicaci√≥n..."
        if curl -s -f http://localhost:${TEST_PORT}/ > /dev/null 2>&1; then
          echo "‚úÖ Aplicaci√≥n respondiendo en puerto ${TEST_PORT}"
        else
          echo "‚ö†Ô∏è La aplicaci√≥n no responde"
          pm2 logs ${APP_NAME} --lines 20 --nostream
        fi
        
        # Test de la ruta /test a trav√©s de Nginx
        if curl -s -f -k https://localhost/test > /dev/null 2>&1; then
          echo "‚úÖ Ruta /test accesible a trav√©s de Nginx"
        else
          echo "‚ö†Ô∏è Ruta /test no accesible (requiere dominio v√°lido)"
        fi
        
        # Resumen final
        echo ""
        echo "========================================="
        echo "üéâ AMBIENTE DE TEST DESPLEGADO"
        echo "========================================="
        echo ""
        echo "üìä INFORMACI√ìN:"
        echo "   - Rama desplegada: ${BRANCH_NAME}"
        echo "   - Aplicaci√≥n PM2: ${APP_NAME}"
        echo "   - Puerto interno: ${TEST_PORT}"
        echo "   - Directorio: ${PROJECT_PATH}"
        echo ""
        echo "üîó ACCESO:"
        echo "   - Producci√≥n: https://${FULL_DOMAIN}/"
        echo "   - Test: https://${FULL_DOMAIN}/test"
        echo ""
        echo "üìç ENDPOINTS DE TEST:"
        echo "   - https://${FULL_DOMAIN}/test/coordenadas"
        echo "   - https://${FULL_DOMAIN}/test/database"
        echo "   - https://${FULL_DOMAIN}/test/version"
        echo "   - https://${FULL_DOMAIN}/test/health"
        echo ""
        echo "üõ†Ô∏è COMANDOS √öTILES:"
        echo "   - Ver logs: pm2 logs ${APP_NAME}"
        echo "   - Reiniciar: pm2 restart ${APP_NAME}"
        echo "   - Estado: pm2 status ${APP_NAME}"
        echo ""
        echo "‚ö†Ô∏è NOTA: Los cambios en /test NO afectan producci√≥n"
        echo "========================================="
        DEPLOYEOF
        
        # Transferir archivo .env
        scp -o StrictHostKeyChecking=no -i deploy_key temp_env_file ${USER}@${HOST}:/tmp/test_env_file
        
        # Transferir y ejecutar el script
        scp -o StrictHostKeyChecking=no -i deploy_key deploy_test_remote.sh ${USER}@${HOST}:/tmp/
        
        ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} \
          "chmod +x /tmp/deploy_test_remote.sh && \
           /tmp/deploy_test_remote.sh '${SUBDOMAIN}' '${DOMAIN_BASE}' '${{ matrix.instance }}' '${BRANCH_NAME}' && \
           if [ -f /tmp/test_env_file ]; then \
             if [ -d /home/ubuntu/Web-server-UDP/test/Proyecto_1_Diseno ]; then \
               mv /tmp/test_env_file /home/ubuntu/Web-server-UDP/test/Proyecto_1_Diseno/.env; \
             else \
               mv /tmp/test_env_file /opt/location-tracker/test/Proyecto_1_Diseno/.env; \
             fi; \
           fi; \
           rm -f /tmp/deploy_test_remote.sh"
        
        # Limpiar archivos temporales
        rm -f deploy_key temp_env_file deploy_test_remote.sh
        
        echo "‚úÖ Despliegue completado"
        echo "üîó Test disponible en: https://${FULL_DOMAIN}/test"