name: Deploy Main to All Instances (Self-Hosted)

on:
  push:
    branches: [main]
    paths:
      - "Proyecto_1_Diseno/**"
      - ".github/workflows/deploy-main.yml"
  workflow_dispatch:

jobs:
<<<<<<< HEAD
  deploy-feature:
    name: Deploy to ${{ github.event.inputs.branch || github.ref_name }}
    runs-on: 
      - self-hosted
      - EC2
      - ${{ github.event.inputs.branch || github.ref_name }}
    
    steps:
    - name: Verify EC2 instance
      run: |
        echo "ðŸ” Verificando instancia EC2..."
        INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id || echo "No disponible")
        HOSTNAME=$(hostname)
        echo "ðŸ“ Instance ID: $INSTANCE_ID"
        echo "ðŸ“ Hostname: $HOSTNAME"
        echo "âœ… Ejecutando en modo SELF-HOSTED"
    
    - name: Determine configuration
      id: config
      run: |
        # Determinar la rama actual
        if [ "${{ github.event_name }}" = "push" ]; then
          BRANCH_NAME="${{ github.ref_name }}"
        else
          BRANCH_NAME="${{ github.event.inputs.branch }}"
        fi
        
        echo "Branch to deploy: ${BRANCH_NAME}"
        
        # Mapear rama a instancia
        case "${BRANCH_NAME}" in
          "Oliver-branch")
            INSTANCE_NUM=1
            PERSON_NAME="Oliver"
            ;;
          "Hernando-branch")
            INSTANCE_NUM=2
            PERSON_NAME="Hernando"
            ;;
          "Alan-branch")
            INSTANCE_NUM=3
            PERSON_NAME="Alan"
            ;;
          "Sebastian-branch")
            INSTANCE_NUM=4
            PERSON_NAME="Sebastian"
            ;;
          *)
            echo "âŒ Rama no reconocida: ${BRANCH_NAME}"
            exit 1
            ;;
        esac
        
        echo "TARGET_INSTANCE=${INSTANCE_NUM}" >> $GITHUB_OUTPUT
        echo "BRANCH_NAME=${BRANCH_NAME}" >> $GITHUB_OUTPUT
        echo "PERSON_NAME=${PERSON_NAME}" >> $GITHUB_OUTPUT
        
        echo "ðŸ  SELF-HOSTED: Desplegando ${BRANCH_NAME} localmente en instancia ${INSTANCE_NUM}"

    - name: Checkout branch
      uses: actions/checkout@v3
      with:
        ref: ${{ steps.config.outputs.BRANCH_NAME }}

    - name: Deploy to local instance
      env:
        ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', steps.config.outputs.TARGET_INSTANCE)] }}
        DOMAIN_BASE: tumaquinaya.com
        BRANCH_NAME: ${{ steps.config.outputs.BRANCH_NAME }}
        PERSON_NAME: ${{ steps.config.outputs.PERSON_NAME }}
        INSTANCE_NUM: ${{ steps.config.outputs.TARGET_INSTANCE }}
      run: |
        echo "ðŸš€ SELF-HOSTED: Desplegando ${BRANCH_NAME} localmente"
        
        # Crear archivo .env directamente
        echo "$ENV_FILE" > /tmp/test_env_file
        
        # Extraer NAME del .env
        NAME_VALUE=$(grep "^NAME=" /tmp/test_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | xargs)
        NAME_LOWER=$(echo "$NAME_VALUE" | tr '[:upper:]' '[:lower:]')
        PERSON_LOWER=$(echo "$PERSON_NAME" | tr '[:upper:]' '[:lower:]')
        
        if [ "${NAME_LOWER}" != "${PERSON_LOWER}" ]; then
            echo "âš ï¸ ADVERTENCIA: El NAME en .env (${NAME_VALUE}) no coincide con ${PERSON_NAME}"
        fi
        
        FULL_DOMAIN="${NAME_LOWER}.${DOMAIN_BASE}"
        
        echo "ðŸ“‹ ConfiguraciÃ³n:"
        echo "   - Rama: ${BRANCH_NAME}"
        echo "   - Persona: ${PERSON_NAME}"
        echo "   - Instancia: ${INSTANCE_NUM}"
        echo "   - Dominio: ${FULL_DOMAIN}"
        echo "   - Modo: SELF-HOSTED (local)"
        
        # Crear script de despliegue local
        cat > /tmp/deploy_test_local.sh << 'DEPLOYEOF'
        #!/bin/bash
        set -e
        
        SUBDOMAIN="${1}"
        DOMAIN_BASE="${2}"
        INSTANCE_NUM="${3}"
        BRANCH_NAME="${4}"
        PERSON_NAME="${5}"
        
        echo "ðŸ”§ ConfiguraciÃ³n de despliegue /test (SELF-HOSTED):"
        echo "   - Rama: ${BRANCH_NAME}"
        echo "   - Persona: ${PERSON_NAME}"
        echo "   - Subdominio: ${SUBDOMAIN}"
        echo "   - Dominio: ${SUBDOMAIN}.${DOMAIN_BASE}"
        echo "   - Instancia: ${INSTANCE_NUM}"
        
        BASE_DIR="/opt/location-tracker"
        TEST_DIR="${BASE_DIR}/test"
        mkdir -p "${TEST_DIR}"
        cd "${TEST_DIR}"
        
        echo "ðŸ“ Directorio de test: ${TEST_DIR}"
        
        if [ -d .git ]; then
          echo "ðŸ“¦ Actualizando cÃ³digo de la rama ${BRANCH_NAME}..."
          git fetch origin ${BRANCH_NAME}
          git checkout ${BRANCH_NAME}
          git reset --hard origin/${BRANCH_NAME}
          CODE_UPDATED=true
        else
          echo "ðŸ“¥ Clonando repositorio en rama ${BRANCH_NAME}..."
          git clone -b ${BRANCH_NAME} https://github.com/Diseno2025-30/Geolocation.git .
          CODE_UPDATED=true
        fi
        
        cd Proyecto_1_Diseno
        PROJECT_PATH=$(pwd)
        
        if [ -f "${BASE_DIR}/Proyecto_1_Diseno/.env" ]; then
          cp "${BASE_DIR}/Proyecto_1_Diseno/.env" .env
        fi
        
        echo "" >> .env
        echo "# ConfiguraciÃ³n de test" >> .env
        echo "TEST_MODE=true" >> .env
        echo "BRANCH_NAME=${BRANCH_NAME}" >> .env
        echo "PERSON_NAME=${PERSON_NAME}" >> .env
        
        FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
        APP_NAME="flask-test-${SUBDOMAIN}"
        TEST_PORT=6000
        
        echo "ðŸ“Š ConfiguraciÃ³n:"
        echo "   - APP_NAME: ${APP_NAME}"
        echo "   - Puerto test: ${TEST_PORT}"
        echo "   - Proyecto: ${PROJECT_PATH}"
        
        echo "ðŸ“¦ Instalando dependencias..."
        sudo apt-get update -qq
        sudo apt-get install -y python3-pip python3-venv nginx
        
        if ! command -v pm2 &> /dev/null; then
          if ! command -v node &> /dev/null; then
            curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
            sudo apt-get install -y nodejs
          fi
          sudo npm install -g pm2
          pm2 startup systemd -u ubuntu --hp /home/ubuntu
        fi
        
        echo "ðŸ Configurando entorno Python para test..."
        if [ ! -d "venv" ]; then
          python3 -m venv venv
        fi
        
        source venv/bin/activate
        pip install --upgrade pip
        pip install flask psycopg2-binary python-dotenv
        
        if [ -f requirements.txt ]; then
          pip install -r requirements.txt
        fi
        
        pm2 stop ${APP_NAME} 2>/dev/null || true
        pm2 delete ${APP_NAME} 2>/dev/null || true
        sudo fuser -k ${TEST_PORT}/tcp 2>/dev/null || true
        sleep 2
        
        cat > start_test_app.sh << STARTSCRIPT
        #!/bin/bash
        cd "\$(dirname "\$0")"
        source venv/bin/activate
        export FLASK_APP=udp_flask_server.py
        export FLASK_ENV=development
        python udp_flask_server.py --port ${TEST_PORT}
        STARTSCRIPT
        chmod +x start_test_app.sh
        
        echo "ðŸŒ Configurando Nginx para /test..."
        NGINX_CONF="/etc/nginx/sites-available/location-tracker"
        sudo sed -i '/# ===== INICIO RUTAS TEST/,/# ===== FIN RUTAS TEST/d' ${NGINX_CONF}
        
        cat > /tmp/nginx-test-inject.conf << NGINXTEST
        
        # ===== INICIO RUTAS TEST =====
        # Rama: ${BRANCH_NAME} - Persona: ${PERSON_NAME}
        # Actualizado: $(date)
        
        location = /test {
            return 301 /test/;
        }
        
        location /test/ {
            proxy_pass http://localhost:${TEST_PORT}/;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
            proxy_set_header X-Script-Name /test;
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
            proxy_buffering off;
        }
        
        location ~ ^/test/(coordenadas|database|version|health)$ {
            proxy_pass http://localhost:${TEST_PORT}/\$1;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }
        
        location /test/static/ {
            alias ${PROJECT_PATH}/static/;
            expires 30d;
            add_header Cache-Control "public, immutable";
        }
        
        # ===== FIN RUTAS TEST =====
        
        NGINXTEST
        
        sudo awk '
        /location \/ \{/ {
            while ((getline line < "/tmp/nginx-test-inject.conf") > 0)
                print line
            close("/tmp/nginx-test-inject.conf")
        }
        { print }
        ' ${NGINX_CONF} > /tmp/nginx-new.conf
        
        sudo mv /tmp/nginx-new.conf ${NGINX_CONF}
        rm -f /tmp/nginx-test-inject.conf
        
        if sudo nginx -t; then
          sudo systemctl reload nginx
          echo "âœ… Nginx configurado para /test"
        else
          echo "âŒ Error en configuraciÃ³n de Nginx"
          sudo nginx -t
          exit 1
        fi
        
        echo "ðŸš€ Iniciando aplicaciÃ³n de test..."
        pm2 start start_test_app.sh \
          --name ${APP_NAME} \
          --interpreter bash \
          --cwd ${PROJECT_PATH} \
          --log-date-format "YYYY-MM-DD HH:mm:ss"
        
        pm2 save
        
        echo "â³ Esperando inicio de la aplicaciÃ³n..."
        sleep 5
        
        echo "ðŸ“Š Estado de la aplicaciÃ³n:"
        pm2 status ${APP_NAME}
        
        echo "ðŸ§ª Probando aplicaciÃ³n..."
        if curl -s -f http://localhost:${TEST_PORT}/ > /dev/null 2>&1; then
          echo "âœ… AplicaciÃ³n respondiendo en puerto ${TEST_PORT}"
        else
          echo "âš ï¸ La aplicaciÃ³n no responde"
          pm2 logs ${APP_NAME} --lines 20 --nostream
        fi
        
        echo ""
        echo "========================================="
        echo "ðŸŽ‰ AMBIENTE DE TEST DESPLEGADO (SELF-HOSTED)"
        echo "========================================="
        echo ""
        echo "ðŸ“Š INFORMACIÃ“N:"
        echo "   - Persona: ${PERSON_NAME}"
        echo "   - Rama: ${BRANCH_NAME}"
        echo "   - Instancia EC2: ${INSTANCE_NUM}"
        echo "   - AplicaciÃ³n PM2: ${APP_NAME}"
        echo "   - Puerto interno: ${TEST_PORT}"
        echo "   - Modo: LOCAL (sin SSH)"
        echo ""
        echo "ðŸ”— URLS:"
        echo "   - ProducciÃ³n (main): https://${FULL_DOMAIN}/"
        echo "   - Test (${BRANCH_NAME}): https://${FULL_DOMAIN}/test"
        echo ""
        echo "ðŸ“ ENDPOINTS DE TEST:"
        echo "   - https://${FULL_DOMAIN}/test/coordenadas"
        echo "   - https://${FULL_DOMAIN}/test/database"
        echo "   - https://${FULL_DOMAIN}/test/version"
        echo "   - https://${FULL_DOMAIN}/test/health"
        echo ""
        echo "ðŸ› ï¸ COMANDOS ÃšTILES:"
        echo "   - Ver logs test: pm2 logs ${APP_NAME}"
        echo "   - Reiniciar test: pm2 restart ${APP_NAME}"
        echo "   - Ver logs prod: pm2 logs flask-app-${SUBDOMAIN}"
        echo "   - Estado: pm2 status"
        echo "========================================="
        DEPLOYEOF
        
        chmod +x /tmp/deploy_test_local.sh
        
        # Ejecutar localmente (sin SSH)
        /tmp/deploy_test_local.sh "${NAME_LOWER}" "${DOMAIN_BASE}" "${INSTANCE_NUM}" "${BRANCH_NAME}" "${PERSON_NAME}"
        
        # Mover el archivo .env a su ubicaciÃ³n final
        if [ -f /tmp/test_env_file ]; then
          mv /tmp/test_env_file /opt/location-tracker/test/Proyecto_1_Diseno/.env
        fi
        
        # Limpiar
        rm -f /tmp/deploy_test_local.sh
        
        echo "âœ… Despliegue SELF-HOSTED completado para ${PERSON_NAME}"
=======
  deploy:
    name: Deploy to Instance ${{ matrix.instance }}

    strategy:
      fail-fast: false
      matrix:
        instance: [1, 2, 3, 4]
        include:
          - instance: 1
            branch: Oliver-branch
            person: Oliver
          - instance: 2
            branch: Hernando-branch
            person: Hernando
          - instance: 3
            branch: Alan-branch
            person: Alan
          - instance: 4
            branch: Sebastian-branch
            person: Sebastian

    runs-on:
      - self-hosted
      - EC2
      - ${{ matrix.branch }}

    steps:
      - name: Verify EC2 instance
        run: |
          echo "ðŸ” Verificando instancia EC2..."
          echo "ðŸ“ Person: ${{ matrix.person }}"
          echo "âœ… Ejecutando en modo SELF-HOSTED (local)"

      - name: Checkout main branch
        uses: actions/checkout@v3
        with:
          ref: main

      - name: Deploy to Production Instance
        env:
          ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', matrix.instance)] }}
          INSTANCE_NUM: ${{ matrix.instance }}
          PERSON_NAME: ${{ matrix.person }}
          DOMAIN_BASE: tumaquinaya.com
        run: |
          echo "ðŸš€ SELF-HOSTED: Desplegando rama main a producciÃ³n"
          echo "   - Instancia: ${INSTANCE_NUM}"
          echo "   - Persona: ${PERSON_NAME}"

          # Crear archivo .env temporal
          echo "$ENV_FILE" > /tmp/prod_env_file

          # Extraer NAME del .env
          NAME_VALUE=$(grep "^NAME=" /tmp/prod_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | xargs)
          NAME_LOWER=$(echo "$NAME_VALUE" | tr '[:upper:]' '[:lower:]')
          PERSON_LOWER=$(echo "$PERSON_NAME" | tr '[:upper:]' '[:lower:]')

          if [ "${NAME_LOWER}" != "${PERSON_LOWER}" ]; then
              echo "âš ï¸ ADVERTENCIA: El NAME en .env (${NAME_VALUE}) no coincide con ${PERSON_NAME}"
          fi

          FULL_DOMAIN="${NAME_LOWER}.${DOMAIN_BASE}"

          echo "ðŸ“‹ ConfiguraciÃ³n:"
          echo "   - Rama: main (producciÃ³n)"
          echo "   - Persona: ${PERSON_NAME}"
          echo "   - Instancia: ${INSTANCE_NUM}"
          echo "   - Dominio: ${FULL_DOMAIN}"
          echo "   - Modo: SELF-HOSTED (local)"

          # Crear script de despliegue local
          cat > /tmp/deploy_prod_local.sh << 'DEPLOYEOF'
          #!/bin/bash
          set -e

          SUBDOMAIN="${1}"
          DOMAIN_BASE="${2}"
          INSTANCE_NUM="${3}"
          PERSON_NAME="${4}"

          echo "ðŸ”§ ConfiguraciÃ³n de despliegue PRODUCCIÃ“N (SELF-HOSTED):"
          echo "   - Rama: main"
          echo "   - Persona: ${PERSON_NAME}"
          echo "   - Subdominio: ${SUBDOMAIN}"
          echo "   - Dominio: ${SUBDOMAIN}.${DOMAIN_BASE}"
          echo "   - Instancia: ${INSTANCE_NUM}"

          # Determinar el directorio base
          BASE_DIR="/opt/location-tracker"

          # Si existe el directorio legacy, usarlo
          if [ -d "/home/ubuntu/Web-server-UDP" ]; then
            echo "ðŸ“ Usando directorio legacy: /home/ubuntu/Web-server-UDP"
            cd /home/ubuntu/Web-server-UDP
            PROJECT_PATH="/home/ubuntu/Web-server-UDP/Proyecto_1_Diseno"
          else
            echo "ðŸ“ Usando directorio estÃ¡ndar: ${BASE_DIR}"
            sudo mkdir -p ${BASE_DIR}
            sudo chown $USER:$USER ${BASE_DIR}
            cd ${BASE_DIR}
            PROJECT_PATH="${BASE_DIR}/Proyecto_1_Diseno"
          fi

          # Actualizar o clonar el repositorio
          if [ -d .git ]; then
            echo "ðŸ“¦ Actualizando cÃ³digo de la rama main..."
            git fetch origin main
            git checkout main
            git reset --hard origin/main
            CODE_UPDATED=true
          else
            echo "ðŸ“¥ Clonando repositorio (rama main)..."
            git clone -b main https://github.com/Diseno2025-30/Geolocation.git .
            CODE_UPDATED=true
          fi

          cd Proyecto_1_Diseno

          # Copiar el archivo .env desde temporal
          if [ -f /tmp/prod_env_file ]; then
            cp /tmp/prod_env_file .env
            echo "âœ… Archivo .env copiado"
          else
            echo "âŒ No se encontrÃ³ el archivo .env temporal"
            exit 1
          fi

          # Agregar informaciÃ³n adicional al .env
          echo "" >> .env
          echo "# ConfiguraciÃ³n de producciÃ³n" >> .env
          echo "PRODUCTION_MODE=true" >> .env
          echo "BRANCH_NAME=main" >> .env
          echo "PERSON_NAME=${PERSON_NAME}" >> .env
          echo "DEPLOYMENT_TIME=$(date -Iseconds)" >> .env

          FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
          APP_NAME="flask-app-${SUBDOMAIN}"
          PROD_PORT=5000

          echo "ðŸ“Š ConfiguraciÃ³n de aplicaciÃ³n:"
          echo "   - APP_NAME: ${APP_NAME}"
          echo "   - Puerto: ${PROD_PORT}"
          echo "   - Proyecto: ${PROJECT_PATH}"

          # Instalar dependencias del sistema
          echo "ðŸ“¦ Instalando dependencias del sistema..."
          sudo apt-get update -qq
          sudo apt-get install -y python3-pip python3-venv nginx certbot python3-certbot-nginx

          # Instalar PM2 si no existe
          if ! command -v pm2 &> /dev/null; then
            echo "ðŸ“¦ Instalando PM2..."
            if ! command -v node &> /dev/null; then
              curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
              sudo apt-get install -y nodejs
            fi
            sudo npm install -g pm2
            pm2 startup systemd -u ubuntu --hp /home/ubuntu
          fi

          # Configurar entorno Python
          echo "ðŸ Configurando entorno Python..."
          if [ ! -d "venv" ]; then
            python3 -m venv venv
          fi

          source venv/bin/activate
          pip install --upgrade pip
          pip install flask psycopg2-binary python-dotenv

          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi

          # Detener aplicaciÃ³n existente si estÃ¡ corriendo
          pm2 stop ${APP_NAME} 2>/dev/null || true
          pm2 delete ${APP_NAME} 2>/dev/null || true
          sudo fuser -k ${PROD_PORT}/tcp 2>/dev/null || true
          sleep 2

          # Crear script de inicio
          cat > start_app.sh << STARTSCRIPT
          #!/bin/bash
          cd "\$(dirname "\$0")"
          source venv/bin/activate
          export FLASK_APP=udp_flask_server.py
          export FLASK_ENV=production
          python udp_flask_server.py --port ${PROD_PORT}
          STARTSCRIPT
          chmod +x start_app.sh

          # Configurar Nginx
          echo "ðŸŒ Configurando Nginx..."
          NGINX_CONF="/etc/nginx/sites-available/location-tracker"

          # Primero, extraer las rutas de TEST existentes si existen
          if [ -f ${NGINX_CONF} ]; then
            echo "ðŸ“‹ Preservando configuraciÃ³n de /test existente..."
            sudo sed -n '/# ===== INICIO RUTAS TEST/,/# ===== FIN RUTAS TEST/p' ${NGINX_CONF} > /tmp/test_routes.txt
            
            if [ -s /tmp/test_routes.txt ]; then
              echo "âœ… Rutas de /test encontradas y preservadas"
            else
              echo "â„¹ï¸ No hay rutas de /test configuradas"
            fi
          fi

          # Crear configuraciÃ³n base de Nginx para producciÃ³n
          cat > /tmp/nginx_base.conf << NGINXCONF
          server {
              listen 80;
              server_name ${FULL_DOMAIN};

              client_max_body_size 10M;

              # ===== INICIO RUTAS PRODUCCION =====
              # Rama: main - Persona: ${PERSON_NAME}
              # Actualizado: $(date)
              
              # ProducciÃ³n en /
              location / {
                  proxy_pass http://localhost:${PROD_PORT};
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  proxy_connect_timeout 60s;
                  proxy_send_timeout 60s;
                  proxy_read_timeout 60s;
                  proxy_buffering off;
              }

              location /static/ {
                  alias ${PROJECT_PATH}/static/;
                  expires 30d;
                  add_header Cache-Control "public, immutable";
              }

              # Endpoints especÃ­ficos de producciÃ³n
              location ~ ^/(coordenadas|database|version|health)$ {
                  proxy_pass http://localhost:${PROD_PORT}/\$1;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
              }
              
              # ===== FIN RUTAS PRODUCCION =====
          NGINXCONF

          # Si hay rutas de test, insertarlas antes del cierre del server
          if [ -s /tmp/test_routes.txt ]; then
            echo "" >> /tmp/nginx_base.conf
            cat /tmp/test_routes.txt >> /tmp/nginx_base.conf
            echo "" >> /tmp/nginx_base.conf
          fi

          # Cerrar el bloque server
          echo "}" >> /tmp/nginx_base.conf

          # Aplicar la configuraciÃ³n
          sudo cp /tmp/nginx_base.conf ${NGINX_CONF}

          # Limpiar archivos temporales
          rm -f /tmp/nginx_base.conf /tmp/test_routes.txt

          # Habilitar el sitio
          sudo ln -sf ${NGINX_CONF} /etc/nginx/sites-enabled/
          sudo rm -f /etc/nginx/sites-enabled/default

          # Verificar y recargar Nginx
          if sudo nginx -t; then
            sudo systemctl reload nginx
            echo "âœ… Nginx configurado correctamente"
          else
            echo "âŒ Error en configuraciÃ³n de Nginx"
            sudo nginx -t
            exit 1
          fi

          # Configurar SSL con Certbot (solo si no existe)
          if [ ! -d "/etc/letsencrypt/live/${FULL_DOMAIN}" ]; then
            echo "ðŸ” Configurando certificado SSL..."
            sudo certbot --nginx -d ${FULL_DOMAIN} \
              --non-interactive \
              --agree-tos \
              --email admin@${DOMAIN_BASE} \
              --redirect || echo "âš ï¸ No se pudo configurar SSL automÃ¡ticamente"
          else
            echo "âœ… Certificado SSL ya existe"
          fi

          # Iniciar aplicaciÃ³n con PM2
          echo "ðŸš€ Iniciando aplicaciÃ³n..."
          pm2 start start_app.sh \
            --name ${APP_NAME} \
            --interpreter bash \
            --cwd ${PROJECT_PATH} \
            --log-date-format "YYYY-MM-DD HH:mm:ss" \
            --max-memory-restart 500M

          pm2 save

          # Esperar a que la aplicaciÃ³n inicie
          echo "â³ Esperando inicio de la aplicaciÃ³n..."
          sleep 5

          # Verificar estado
          echo "ðŸ“Š Estado de la aplicaciÃ³n:"
          pm2 status ${APP_NAME}

          # Probar la aplicaciÃ³n
          echo "ðŸ§ª Probando aplicaciÃ³n..."
          if curl -s -f http://localhost:${PROD_PORT}/ > /dev/null 2>&1; then
            echo "âœ… AplicaciÃ³n respondiendo en puerto ${PROD_PORT}"
          else
            echo "âš ï¸ La aplicaciÃ³n no responde inmediatamente"
            pm2 logs ${APP_NAME} --lines 20 --nostream
          fi

          # Probar endpoints
          echo "ðŸ” Verificando endpoints..."
          for endpoint in health version; do
            if curl -s -f http://localhost:${PROD_PORT}/${endpoint} > /dev/null 2>&1; then
              echo "   âœ… /${endpoint} respondiendo"
            else
              echo "   âš ï¸ /${endpoint} no responde"
            fi
          done

          echo ""
          echo "========================================="
          echo "ðŸŽ‰ PRODUCCIÃ“N DESPLEGADA (SELF-HOSTED)"
          echo "========================================="
          echo ""
          echo "ðŸ“Š INFORMACIÃ“N:"
          echo "   - Persona: ${PERSON_NAME}"
          echo "   - Rama: main (producciÃ³n)"
          echo "   - Instancia EC2: ${INSTANCE_NUM}"
          echo "   - AplicaciÃ³n PM2: ${APP_NAME}"
          echo "   - Puerto: ${PROD_PORT}"
          echo "   - Modo: SELF-HOSTED (local)"
          echo ""
          echo "ðŸ”— URLS:"
          echo "   - HTTP: http://${FULL_DOMAIN}"
          echo "   - HTTPS: https://${FULL_DOMAIN}"
          echo ""
          echo "ðŸ“ ENDPOINTS:"
          echo "   - https://${FULL_DOMAIN}/coordenadas"
          echo "   - https://${FULL_DOMAIN}/database"
          echo "   - https://${FULL_DOMAIN}/version"
          echo "   - https://${FULL_DOMAIN}/health"
          echo ""
          echo "ðŸ› ï¸ COMANDOS ÃšTILES:"
          echo "   - Ver logs: pm2 logs ${APP_NAME}"
          echo "   - Reiniciar: pm2 restart ${APP_NAME}"
          echo "   - Monitorear: pm2 monit"
          echo "   - Estado: pm2 status"
          echo "========================================="
          DEPLOYEOF

          chmod +x /tmp/deploy_prod_local.sh

          # Ejecutar localmente (sin SSH)
          /tmp/deploy_prod_local.sh "${NAME_LOWER}" "${DOMAIN_BASE}" "${INSTANCE_NUM}" "${PERSON_NAME}"

          # Limpiar archivos temporales
          rm -f /tmp/deploy_prod_local.sh /tmp/prod_env_file

          echo "âœ… Despliegue SELF-HOSTED completado para ${PERSON_NAME} en producciÃ³n"
>>>>>>> c71b9e50632ea7f146b20363349e80133c163a23
