name: Deploy Feature Branch to Test

on:
  push:
    branches:
      - Oliver-branch
      - Hernando-branch
      - Alan-branch
      - Sebastian-branch

  workflow_dispatch:
    inputs:
      branch:
        description: "Feature branch to deploy"
        required: true
        type: choice
        options:
          - Oliver-branch
          - Hernando-branch
          - Alan-branch
          - Sebastian-branch

jobs:
  deploy-feature:
    runs-on: ubuntu-latest

    steps:
      - name: Determine target instance
        id: determine-instance
        run: |
          # Determinar la rama actual
          if [ "${{ github.event_name }}" = "push" ]; then
            BRANCH_NAME="${{ github.ref_name }}"
          else
            BRANCH_NAME="${{ github.event.inputs.branch }}"
          fi

          echo "Branch to deploy: ${BRANCH_NAME}"

          # Mapear rama a instancia
          case "${BRANCH_NAME}" in
            "Oliver-branch")
              INSTANCE_NUM=1
              PERSON_NAME="Oliver"
              ;;
            "Hernando-branch")
              INSTANCE_NUM=2
              PERSON_NAME="Hernando"
              ;;
            "Alan-branch")
              INSTANCE_NUM=3
              PERSON_NAME="Alan"
              ;;
            "Sebastian-branch")
              INSTANCE_NUM=4
              PERSON_NAME="Sebastian"
              ;;
            *)
              echo "‚ùå Rama no reconocida: ${BRANCH_NAME}"
              exit 1
              ;;
          esac

          echo "TARGET_INSTANCE=${INSTANCE_NUM}" >> $GITHUB_OUTPUT
          echo "BRANCH_NAME=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "PERSON_NAME=${PERSON_NAME}" >> $GITHUB_OUTPUT

          echo "‚úÖ Desplegando ${BRANCH_NAME} a instancia ${INSTANCE_NUM} (${PERSON_NAME})"

      - name: Checkout branch
        uses: actions/checkout@v3
        with:
          ref: ${{ steps.determine-instance.outputs.BRANCH_NAME }}

      - name: Deploy to assigned instance
        env:
          HOST: ${{ secrets[format('EC2_HOST_{0}', steps.determine-instance.outputs.TARGET_INSTANCE)] }}
          USER: ${{ secrets[format('EC2_USER_{0}', steps.determine-instance.outputs.TARGET_INSTANCE)] }}
          KEY: ${{ secrets[format('EC2_SSH_KEY_{0}', steps.determine-instance.outputs.TARGET_INSTANCE)] }}
          ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', steps.determine-instance.outputs.TARGET_INSTANCE)] }}
          FIREBASE_SDK: ${{ secrets.FIREBASE_SDK_JSON }}
          DOMAIN_BASE: tumaquinaya.com
          BRANCH_NAME: ${{ steps.determine-instance.outputs.BRANCH_NAME }}
          PERSON_NAME: ${{ steps.determine-instance.outputs.PERSON_NAME }}
          INSTANCE_NUM: ${{ steps.determine-instance.outputs.TARGET_INSTANCE }}
        run: |
          echo "üöÄ Desplegando ${BRANCH_NAME} en instancia ${INSTANCE_NUM} (${PERSON_NAME}.${DOMAIN_BASE})"

          # Crear archivo de llave SSH
          echo "$KEY" > deploy_key
          chmod 600 deploy_key

          # Crear archivo .env temporal
          echo "$ENV_FILE" > temp_env_file

          echo "$FIREBASE_SDK" > temp_sdk.json

          # Verificar que el NAME coincida con la persona asignada
          NAME_VALUE=$(grep "^NAME=" temp_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | xargs)
          NAME_LOWER=$(echo "$NAME_VALUE" | tr '[:upper:]' '[:lower:]')
          PERSON_LOWER=$(echo "$PERSON_NAME" | tr '[:upper:]' '[:lower:]')

          if [ "${NAME_LOWER}" != "${PERSON_LOWER}" ]; then
              echo "‚ö†Ô∏è ADVERTENCIA: El NAME en .env (${NAME_VALUE}) no coincide con la persona asignada (${PERSON_NAME})"
              echo "   Esto puede causar inconsistencias. Verificar configuraci√≥n."
          fi

          FULL_DOMAIN="${NAME_LOWER}.${DOMAIN_BASE}"

          echo "üìã Configuraci√≥n:"
          echo "   - Rama: ${BRANCH_NAME}"
          echo "   - Persona: ${PERSON_NAME}"
          echo "   - Instancia: ${INSTANCE_NUM}"
          echo "   - Dominio: ${FULL_DOMAIN}"
          echo "   - URL de test: https://${FULL_DOMAIN}/test"

          # ========== SCRIPT OSRM - BARRANQUILLA OFICIAL ==========
          cat > setup_osrm.sh << 'OSRMEOF'
          #!/bin/bash
          set -e

          echo "üó∫Ô∏è ========================================="
          echo "üó∫Ô∏è CONFIGURANDO OSRM - BARRANQUILLA OFICIAL"
          echo "üó∫Ô∏è ========================================="

          # ========== VERIFICAR Y ELIMINAR MAPA ANTIGUO ==========
          echo "üîç Verificando mapa actual..."

          # Verificar si existe el mapa antiguo del puerto
          if [ -f "/opt/osrm-data/puerto-barranquilla.osrm" ] || docker ps 2>/dev/null | grep -q osrm-backend; then
            echo "üóëÔ∏è  Eliminando mapa antiguo del puerto y contenedor..."
            
            # Detener y eliminar contenedor
            docker stop osrm-backend 2>/dev/null || true
            docker rm osrm-backend 2>/dev/null || true
            
            # Eliminar archivos del mapa antiguo
            sudo rm -f /opt/osrm-data/puerto-barranquilla.*
            sudo rm -f /opt/osrm-data/barranquilla-oficial.* 2>/dev/null || true
            
            echo "‚úÖ Mapa antiguo y contenedor eliminados"
            FORCE_REINSTALL=true
          else
            echo "‚úÖ No se encontr√≥ mapa antiguo, procediendo con instalaci√≥n nueva"
            FORCE_REINSTALL=false
          fi

          echo "üì¶ Instalando dependencias..."

          # Instalar Docker si no est√° instalado
          if ! command -v docker &> /dev/null; then
            echo "üê≥ Instalando Docker..."
            sudo apt-get update -qq
            sudo apt-get install -y docker.io
            sudo systemctl start docker
            sudo systemctl enable docker
            echo "‚úÖ Docker instalado"
          else
            echo "‚úÖ Docker ya est√° instalado"
          fi

          # Instalar osmium-tool Y osmctools para convertir formatos
          if ! command -v osmium &> /dev/null; then
            echo "üîß Instalando osmium-tool y osmctools..."
            sudo apt-get update -qq
            sudo apt-get install -y osmium-tool osmctools
            echo "‚úÖ osmium-tool y osmctools instalados"
          else
            echo "‚úÖ osmium-tool ya est√° instalado"
            # Asegurar que osmctools tambi√©n est√© instalado
            if ! command -v osmconvert &> /dev/null; then
              echo "üîß Instalando osmctools..."
              sudo apt-get install -y osmctools
              echo "‚úÖ osmctools instalado"
            else
              echo "‚úÖ osmctools ya est√° instalado"
            fi
          fi

          # ========== PERMISOS DE DOCKER ==========
          echo "üîß Configurando permisos de Docker..."

          echo "   Usuario detectado: ${CURRENT_USER}"

          if ! groups ${CURRENT_USER} | grep -q docker; then
            echo "   Agregando usuario '${CURRENT_USER}' al grupo docker..."
            sudo usermod -aG docker ${CURRENT_USER}
          else
            echo "   Usuario '${CURRENT_USER}' ya est√° en el grupo docker"
          fi

          echo "   Reiniciando Docker daemon..."
          sudo systemctl restart docker
          sleep 2

          sudo chmod 666 /var/run/docker.sock
          echo "‚úÖ Permisos de Docker configurados"
          # =========================================

          # Crear directorio para datos OSRM
          OSRM_DIR="/opt/osrm-data"
          CURRENT_USER=$(whoami)
          echo "üìÅ Creando directorio: ${OSRM_DIR}"
          sudo mkdir -p ${OSRM_DIR}
          sudo chown ${CURRENT_USER}:${CURRENT_USER} ${OSRM_DIR}
          cd ${OSRM_DIR}

          echo ""
          echo "üì• ========================================="
          echo "üì• DESCARGANDO MAPA OFICIAL DE BARRANQUILLA"
          echo "üì• ========================================="
          echo ""
          echo "üó∫Ô∏è M√©todo: Relaci√≥n administrativa oficial"
          echo "   ID Relaci√≥n: 1335179"
          echo "   √Årea: 166 km¬≤ (Municipio completo)"
          echo "   Fuente: OpenStreetMap - Relaci√≥n oficial"
          echo ""

          # Limpiar descargas previas
          rm -f barranquilla-oficial.osm barranquilla-oficial.osm.pbf

          # Query de Overpass CORREGIDA para obtener TODAS las calles dentro del l√≠mite oficial de Barranquilla
          OVERPASS_QUERY='[out:xml][timeout:600];
          (
            relation(1335179);
            map_to_area;
            way(area)["highway"~"^(motorway|trunk|primary|secondary|tertiary|unclassified|residential|service|living_street|pedestrian|track|road)$"];
            >;
          );
          out body;'

          echo "$OVERPASS_QUERY" > /tmp/overpass_query.txt

          MAX_ATTEMPTS=3
          ATTEMPT=1

          echo "üåê Descargando mapa oficial de Barranquilla desde Overpass API..."
          echo "   (Esto puede tardar 2-5 minutos debido al √°rea completa)"
          echo ""

          until curl -L --connect-timeout 300 --max-time 600 \
            --retry 3 --retry-delay 15 \
            -d @/tmp/overpass_query.txt \
            "https://overpass-api.de/api/interpreter" \
            -o barranquilla-oficial.osm; do

            if [ $ATTEMPT -ge $MAX_ATTEMPTS ]; then
              echo ""
              echo "‚ùå Error: No se pudo descargar desde Overpass API despu√©s de $MAX_ATTEMPTS intentos"
              echo "üí° Intentando m√©todo alternativo con bounding box..."
              
              # M√©todo alternativo: bounding box conservadora basada en la relaci√≥n
              OVERPASS_QUERY_ALT='[out:xml][timeout:300][bbox:10.87,-74.93,11.08,-74.72];
              (
                way["highway"~"^(motorway|trunk|primary|secondary|tertiary|unclassified|residential|service|living_street|pedestrian|track|road)$"];
                >;
              );
              out body;'
              
              echo "$OVERPASS_QUERY_ALT" > /tmp/overpass_query_alt.txt
              
              curl -L --connect-timeout 300 --max-time 600 \
                -d @/tmp/overpass_query_alt.txt \
                "https://overpass-api.de/api/interpreter" \
                -o barranquilla-oficial.osm
              break
            fi
            
            echo ""
            echo "‚ö†Ô∏è Intento $ATTEMPT de $MAX_ATTEMPTS fall√≥"
            echo "   Esperando 30 segundos antes de reintentar..."
            ATTEMPT=$((ATTEMPT+1))
            sleep 30
            rm -f barranquilla-oficial.osm
          done

          # Verificar que el archivo se descarg√≥ correctamente
          if [ ! -f "barranquilla-oficial.osm" ] || [ ! -s "barranquilla-oficial.osm" ]; then
            echo "‚ùå Error: No se pudo descargar el mapa de Barranquilla"
            echo "üí° Intentando descargar Colombia completo y extraer Barranquilla..."
            
            wget -O colombia-latest.osm.pbf https://download.geofabrik.de/south-america/colombia-latest.osm.pbf
            
            # Bounding box basada en la relaci√≥n oficial (aproximada)
            osmium extract --bbox -74.93,10.87,-74.72,11.08 colombia-latest.osm.pbf -o barranquilla-oficial.osm.pbf
            rm -f colombia-latest.osm.pbf
            
            # Si usamos PBF directamente, saltar conversi√≥n
            if [ -f "barranquilla-oficial.osm.pbf" ]; then
              echo "‚úÖ Mapa descargado y extra√≠do exitosamente"
              echo "   Archivo PBF: $(ls -lh barranquilla-oficial.osm.pbf | awk '{print $5}')"
              SKIP_CONVERSION=true
            else
              echo "‚ùå Error cr√≠tico: No se pudo obtener el mapa de Barranquilla"
              exit 1
            fi
          else
            echo "‚úÖ Descarga completada exitosamente"
            echo "   Archivo OSM: $(ls -lh barranquilla-oficial.osm | awk '{print $5}')"
            
            # Verificar que el archivo no est√© vac√≠o
            FILE_SIZE=$(stat -c%s barranquilla-oficial.osm 2>/dev/null || stat -f%z barranquilla-oficial.osm)
            if [ $FILE_SIZE -lt 100000 ]; then
              echo "‚ö†Ô∏è Archivo muy peque√±o ($FILE_SIZE bytes), probablemente vac√≠o"
              echo "üí° Usando m√©todo alternativo..."
              rm -f barranquilla-oficial.osm
              
              # Descargar Colombia completo
              wget -O colombia-latest.osm.pbf https://download.geofabrik.de/south-america/colombia-latest.osm.pbf
              osmium extract --bbox -74.93,10.87,-74.72,11.08 colombia-latest.osm.pbf -o barranquilla-oficial.osm.pbf
              rm -f colombia-latest.osm.pbf
              SKIP_CONVERSION=true
            else
              # Convertir OSM a PBF usando osmconvert (m√°s robusto que osmium para archivos grandes)
              echo ""
              echo "üîÑ Convirtiendo formato OSM a PBF..."
              
              # Usar osmconvert que es m√°s robusto con archivos grandes y complejos
              if command -v osmconvert &> /dev/null; then
                echo "   Usando osmconvert (recomendado para archivos grandes)..."
                osmconvert barranquilla-oficial.osm -o=barranquilla-oficial.osm.pbf
              else
                echo "   Usando osmium como fallback..."
                osmium cat barranquilla-oficial.osm -o barranquilla-oficial.osm.pbf --overwrite --input-format=xml,add_metadata=false
              fi
              
              if [ ! -f "barranquilla-oficial.osm.pbf" ]; then
                echo "‚ùå Error en conversi√≥n"
                exit 1
              fi
              
              rm -f barranquilla-oficial.osm
              echo "‚úÖ Conversi√≥n completada"
              echo "   Archivo PBF: $(ls -lh barranquilla-oficial.osm.pbf | awk '{print $5}')"
              SKIP_CONVERSION=false
            fi
          fi

          # ========== PROCESAR CON OSRM ==========
          echo ""
          echo "‚öôÔ∏è ========================================="
          echo "‚öôÔ∏è PROCESANDO MAPA CON OSRM"
          echo "‚öôÔ∏è ========================================="
          echo ""
          echo "   Algoritmo: MLD (Multi-Level Dijkstra)"
          echo "   Perfil: Car (autom√≥viles)"
          echo "   Tiempo estimado: 3-8 minutos"
          echo ""

          echo "üìç Paso 1/3: Extracci√≥n de datos de rutas..."
          if ! docker run -t -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend \
            osrm-extract -p /opt/car.lua /data/barranquilla-oficial.osm.pbf; then
            echo "‚ùå Error en extracci√≥n OSRM"
            echo "üí° Verifica los logs arriba para m√°s detalles"
            exit 1
          fi
          echo "‚úÖ Extracci√≥n completada"

          echo ""
          echo "üóÇÔ∏è Paso 2/3: Particionamiento de grafo..."
          if ! docker run -t -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend \
            osrm-partition /data/barranquilla-oficial.osrm; then
            echo "‚ùå Error en particionamiento OSRM"
            exit 1
          fi
          echo "‚úÖ Particionamiento completado"

          echo ""
          echo "üé® Paso 3/3: Personalizaci√≥n de rutas..."
          if ! docker run -t -v "${PWD}:/data" ghcr.io/project-osrm/osrm-backend \
            osrm-customize /data/barranquilla-oficial.osrm; then
            echo "‚ùå Error en personalizaci√≥n OSRM"
            exit 1
          fi
          echo "‚úÖ Personalizaci√≥n completada"

          echo ""
          echo "‚úÖ Procesamiento OSRM completado exitosamente"

          # Limpiar archivo .osm.pbf para ahorrar espacio
          echo ""
          echo "üßπ Limpiando archivos temporales..."
          rm -f barranquilla-oficial.osm.pbf /tmp/overpass_query.txt /tmp/overpass_query_alt.txt

          echo ""
          echo "üíæ Espacio utilizado:"
          du -sh ${OSRM_DIR}
          echo ""
          echo "üìÇ Archivos finales:"
          ls -lh ${OSRM_DIR}/ | grep barranquilla-oficial

          echo ""
          echo "üöÄ ========================================="
          echo "üöÄ INICIANDO SERVIDOR OSRM"
          echo "üöÄ ========================================="

          # Detener contenedor anterior si existe
          docker stop osrm-backend 2>/dev/null || true
          docker rm osrm-backend 2>/dev/null || true

          # Iniciar servidor OSRM en puerto 5001
          echo "   Puerto: 5001"
          echo "   Algoritmo: MLD"
          echo "   Auto-reinicio: Habilitado"
          echo ""

          docker run -d --name osrm-backend \
            --restart unless-stopped \
            -p 5001:5000 \
            -v "${PWD}:/data" \
            ghcr.io/project-osrm/osrm-backend \
            osrm-routed --algorithm mld /data/barranquilla-oficial.osrm

          # Esperar a que OSRM est√© listo
          echo "‚è≥ Esperando que OSRM est√© listo..."
          for i in {1..40}; do
            if curl -s -f "http://localhost:5001/nearest/v1/driving/-74.81,10.99" > /dev/null 2>&1; then
              echo ""
              echo "‚úÖ OSRM est√° funcionando correctamente"
              break
            fi
            if [ $i -eq 40 ]; then
              echo ""
              echo "‚ùå Timeout esperando OSRM. Ver logs:"
              docker logs osrm-backend --tail 50
              exit 1
            fi
            echo -n "."
            sleep 3
          done

          echo ""
          echo "üîß Configurando servicio systemd para auto-inicio..."

          # Crear servicio systemd
          sudo tee /etc/systemd/system/osrm.service > /dev/null << SERVICEEOF
          [Unit]
          Description=OSRM Backend Service - Barranquilla Oficial
          After=docker.service
          Requires=docker.service

          [Service]
          Type=simple
          User=${CURRENT_USER}
          Restart=always
          RestartSec=10
          ExecStartPre=-/usr/bin/docker stop osrm-backend
          ExecStartPre=-/usr/bin/docker rm osrm-backend
          ExecStart=/usr/bin/docker run --rm --name osrm-backend -p 5001:5000 -v ${OSRM_DIR}:/data ghcr.io/project-osrm/osrm-backend osrm-routed --algorithm mld /data/barranquilla-oficial.osrm
          ExecStop=/usr/bin/docker stop osrm-backend

          [Install]
          WantedBy=multi-user.target
          SERVICEEOF

          sudo systemctl daemon-reload
          sudo systemctl enable osrm

          echo "‚úÖ Servicio systemd configurado"

          # Prueba final exhaustiva
          echo ""
          echo "üß™ ========================================="
          echo "üß™ PRUEBA EXHAUSTIVA DE SNAP-TO-ROADS"
          echo "üß™ ========================================="
          echo ""

          # Probar con diferentes ubicaciones representativas de Barranquilla
          TEST_POINTS=(
            "-74.7818,10.9876"  # Centro Hist√≥rico
            "-74.8065,10.9352"  # Suroriente
            "-74.8250,10.9630"  # Suroccidente
            "-74.7523,10.9741"  # Norte - Riomar
            "-74.7889,10.9198"  # Sur - Las Nieves
          )

          echo "üìç Probando snap-to-roads en 5 ubicaciones clave:"
          for point in "${TEST_POINTS[@]}"; do
            lon=$(echo $point | cut -d',' -f1)
            lat=$(echo $point | cut -d',' -f2)
            echo ""
            echo "   Ubicaci√≥n: ($lat, $lon)"
            RESPONSE=$(curl -s "http://localhost:5001/nearest/v1/driving/$lon,$lat")
            
            if echo "$RESPONSE" | grep -q '"code":"Ok"'; then
              SNAPPED_LAT=$(echo "$RESPONSE" | grep -o '"location":\[[^]]*\]' | head -1 | grep -o '[0-9.-]*' | tail -1)
              SNAPPED_LON=$(echo "$RESPONSE" | grep -o '"location":\[[^]]*\]' | head -1 | grep -o '[0-9.-]*' | head -1)
              DISTANCE=$(echo "$RESPONSE" | grep -o '"distance":[0-9.-]*' | head -1 | grep -o '[0-9.-]*')
              
              echo "   ‚úÖ Ajustado a: ($SNAPPED_LAT, $SNAPPED_LON)"
              echo "   üìè Distancia: ${DISTANCE}m"
            else
              echo "   ‚ùå No se pudo ajustar (fuera del mapa)"
            fi
          done

          echo ""
          echo "========================================="
          echo "‚úÖ INSTALACI√ìN COMPLETADA"
          echo "========================================="
          echo ""
          echo "üìä INFORMACI√ìN DEL SISTEMA:"
          echo "   - Contenedor: osrm-backend"
          echo "   - Puerto: 5001 (host) ‚Üí 5000 (contenedor)"
          echo "   - Datos: ${OSRM_DIR}"
          echo "   - √Årea: Barranquilla Oficial (166 km¬≤)"
          echo "   - Servicio systemd: Habilitado"
          echo ""
          echo "üó∫Ô∏è COBERTURA DEL MAPA:"
          echo "   ‚úÖ Todo el municipio de Barranquilla"
          echo "   ‚úÖ Todas las v√≠as principales y secundarias"
          echo "   ‚úÖ Calles residenciales"
          echo "   ‚úÖ V√≠as de servicio"
          echo ""
          echo "üîó ENDPOINTS DISPONIBLES:"
          echo "   - Nearest: http://localhost:5001/nearest/v1/driving/{lon},{lat}"
          echo "   - Route: http://localhost:5001/route/v1/driving/{coords}"
          echo "   - Match: http://localhost:5001/match/v1/driving/{coords}"
          echo ""
          echo "üõ†Ô∏è COMANDOS √öTILES:"
          echo "   - Ver logs: docker logs -f osrm-backend"
          echo "   - Reiniciar: docker restart osrm-backend"
          echo "   - Estado: docker ps | grep osrm"
          echo "   - Detener: docker stop osrm-backend"
          echo "   - Servicio: sudo systemctl status osrm"
          echo "========================================="
          echo "========================================="
          echo "‚úÖ INSTALACI√ìN COMPLETADA"
          echo "========================================="
          OSRMEOF

          # Crear script de despliegue remoto
          cat > deploy_test_remote.sh << 'DEPLOYEOF'
          #!/bin/bash
          set -e

          # Recibir par√°metros
          SUBDOMAIN="${1}"
          DOMAIN_BASE="${2}"
          INSTANCE_NUM="${3}"
          BRANCH_NAME="${4}"
          PERSON_NAME="${5}"

          echo "üîß Configuraci√≥n de despliegue /test:"
          echo "   - Rama: ${BRANCH_NAME}"
          echo "   - Persona: ${PERSON_NAME}"
          echo "   - Subdominio: ${SUBDOMAIN}"
          echo "   - Dominio: ${SUBDOMAIN}.${DOMAIN_BASE}"
          echo "   - Instancia: ${INSTANCE_NUM}"

          # Determinar ruta base del proyecto
          if [ -d "/home/ubuntu/Web-server-UDP" ]; then
            BASE_DIR="/home/ubuntu/Web-server-UDP"
          else
            BASE_DIR="/opt/location-tracker"
            sudo mkdir -p ${BASE_DIR}
            sudo chown $USER:$USER ${BASE_DIR}
          fi

          # Crear directorio para la versi√≥n test
          TEST_DIR="${BASE_DIR}/test"
          mkdir -p "${TEST_DIR}"
          cd "${TEST_DIR}"

          echo "üìÅ Directorio de test: ${TEST_DIR}"

          # Actualizar o clonar el c√≥digo de la rama
          if [ -d .git ]; then
            echo "üì¶ Actualizando c√≥digo de la rama ${BRANCH_NAME}..."
            git fetch origin ${BRANCH_NAME}
            git checkout ${BRANCH_NAME}
            git reset --hard origin/${BRANCH_NAME}
            CODE_UPDATED=true
          else
            echo "üì• Clonando repositorio en rama ${BRANCH_NAME}..."
            git clone -b ${BRANCH_NAME} https://github.com/Diseno2025-30/Geolocation.git .
            CODE_UPDATED=true
          fi

          # Navegar al directorio del proyecto
          cd Proyecto_1_Diseno
          PROJECT_PATH=$(pwd)

          # üîí CORRECCI√ìN DE PERMISOS PARA NGINX
          echo "üîí Configurando permisos para que Nginx (www-data) pueda acceder..."
          chmod o+rx ${BASE_DIR}
          chmod o+rx ${TEST_DIR}
          chmod o+rx ${PROJECT_PATH}

          # Si existe carpeta static, configurar permisos recursivamente
          if [ -d "static" ]; then
            find static -type d -exec chmod o+rx {} \;
            find static -type f -exec chmod o+r {} \;
            echo "‚úÖ Permisos configurados para carpeta static"
          fi

          # Copiar el archivo .env de producci√≥n y modificarlo
          if [ -f "${BASE_DIR}/Proyecto_1_Diseno/.env" ]; then
            cp "${BASE_DIR}/Proyecto_1_Diseno/.env" .env
          fi

          # Agregar configuraci√≥n espec√≠fica para test
          echo "" >> .env
          echo "# Configuraci√≥n de test" >> .env
          echo "TEST_MODE=true" >> .env
          echo "BRANCH_NAME=${BRANCH_NAME}" >> .env
          echo "PERSON_NAME=${PERSON_NAME}" >> .env

          FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
          APP_NAME="flask-test-${SUBDOMAIN}"
          TEST_PORT=6000

          echo "üìä Configuraci√≥n:"
          echo "   - APP_NAME: ${APP_NAME}"
          echo "   - Puerto test: ${TEST_PORT}"
          echo "   - Proyecto: ${PROJECT_PATH}"

          # Instalar dependencias
          echo "üì¶ Instalando dependencias..."
          sudo apt-get update -qq
          sudo apt-get install -y python3-pip python3-venv nginx

          # PM2 si no est√° instalado
          if ! command -v pm2 &> /dev/null; then
            if ! command -v node &> /dev/null; then
              curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
              sudo apt-get install -y nodejs
            fi
            sudo npm install -g pm2
            pm2 startup systemd -u $USER --hp /home/$USER
          fi

          # Configurar entorno virtual de Python
          echo "üêç Configurando entorno Python para test..."
          if [ ! -d "venv" ]; then
            python3 -m venv venv
          fi

          source venv/bin/activate
          pip install --upgrade pip
          pip install flask psycopg2-binary python-dotenv requests firebase-admin Flask-JWT-Extended

          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi

          # Detener aplicaci√≥n test anterior si existe
          pm2 stop ${APP_NAME} 2>/dev/null || true
          pm2 delete ${APP_NAME} 2>/dev/null || true

          # Liberar puerto
          sudo fuser -k ${TEST_PORT}/tcp 2>/dev/null || true
          sleep 2

          # Crear script de inicio para test
          cat > start_test_app.sh << STARTSCRIPT
          #!/bin/bash
          cd "\$(dirname "\$0")"
          source venv/bin/activate
          export FLASK_APP=run.py
          export FLASK_ENV=development
          python run.py --port ${TEST_PORT}
          STARTSCRIPT
          chmod +x start_test_app.sh

          # Actualizar configuraci√≥n de Nginx para agregar /test
          echo "üåê Configurando Nginx para /test..."

          NGINX_CONF="/etc/nginx/sites-available/location-tracker"

          # Eliminar configuraciones de test anteriores
          sudo sed -i '/# ===== INICIO RUTAS TEST/,/# ===== FIN RUTAS TEST/d' ${NGINX_CONF}
          sudo sed -i '/^[[:space:]]*location[[:space:]]*\/osrm\//,/^[[:space:]]*}[[:space:]]*$/d' ${NGINX_CONF}


          # Crear archivo temporal con las rutas de test
          cat > /tmp/nginx-test-inject.conf << NGINXTEST

          # ===== INICIO RUTAS TEST =====
          # Rama: ${BRANCH_NAME} - Persona: ${PERSON_NAME}
          # Actualizado: $(date)

          # PROXY PARA OSRM (SNAP-TO-ROADS)
          location /osrm/ {
              rewrite ^/osrm/(.*) /\$1 break;
              proxy_pass http://localhost:5001;
              proxy_http_version 1.1;
              proxy_set_header Host \$host;
              proxy_set_header X-Real-IP \$remote_addr;
              proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto \$scheme;
              
              # Timeouts para OSRM
              proxy_connect_timeout 60s;
              proxy_send_timeout 60s;
              proxy_read_timeout 60s;
              
              # CORS para permitir acceso desde JavaScript
              add_header 'Access-Control-Allow-Origin' '*' always;
              add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
              add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range' always;
              
              # Manejar preflight requests
              if (\$request_method = 'OPTIONS') {
                  add_header 'Access-Control-Allow-Origin' '*';
                  add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
                  add_header 'Access-Control-Max-Age' 1728000;
                  add_header 'Content-Type' 'text/plain; charset=utf-8';
                  add_header 'Content-Length' 0;
                  return 204;
              }
          }

          location = /test {
              return 301 /test/;
          }

          location /test/static/ {
              alias ${PROJECT_PATH}/static/;
              add_header Cache-Control "no-cache, no-store, must-revalidate";
              add_header Pragma "no-cache";
              add_header Expires "0";
          }

          location /test/ {
              proxy_pass http://localhost:${TEST_PORT}/;
              proxy_set_header Host \$host;
              proxy_set_header X-Real-IP \$remote_addr;
              proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto \$scheme;
              proxy_set_header X-Script-Name /test;
              proxy_connect_timeout 60s;
              proxy_send_timeout 60s;
              proxy_read_timeout 60s;
              proxy_buffering off;
          }

          location ~ ^/test/(coordenadas|database|version|health)$ {
              proxy_pass http://localhost:${TEST_PORT}/\$1;
              proxy_set_header Host \$host;
              proxy_set_header X-Real-IP \$remote_addr;
              proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto \$scheme;
          }

          # ===== FIN RUTAS TEST =====

          NGINXTEST

          # Insertar las rutas de test en el servidor HTTPS (no en el HTTP)
          sudo awk '
          BEGIN { 
              in_https_server = 0
              inserted = 0
              brace_count = 0
          }

          # Detectar inicio de bloque server
          /^[[:space:]]*server[[:space:]]*\{/ {
              brace_count = 1
              print
              getline
              # Si la siguiente l√≠nea contiene "listen 443", es el servidor HTTPS
              if ($0 ~ /listen 443/) {
                  in_https_server = 1
              }
              print
              next
          }

          # Contar llaves para saber cu√°ndo termina el bloque server
          in_https_server == 1 {
              if ($0 ~ /\{/) brace_count++
              if ($0 ~ /\}/) brace_count--
              
              # Si llegamos al cierre del server, ya no estamos en HTTPS
              if (brace_count == 0) {
                  in_https_server = 0
              }
          }

          # Insertar el bloque TEST antes del PRIMER "location /" dentro del servidor HTTPS
          in_https_server == 1 && /^[[:space:]]*location[[:space:]]+\/[[:space:]]+\{/ && inserted == 0 {
              # Leer e insertar el archivo de configuraciones TEST
              while ((getline line < "/tmp/nginx-test-inject.conf") > 0) {
                  print line
              }
              close("/tmp/nginx-test-inject.conf")
              inserted = 1
              print
              next
          }

          # Imprimir todas las dem√°s l√≠neas
          { print }
          ' ${NGINX_CONF} > /tmp/nginx-new.conf

          # Verificar que el archivo se cre√≥ correctamente
          if [ ! -s /tmp/nginx-new.conf ]; then
              echo "‚ùå Error: El archivo de configuraci√≥n generado est√° vac√≠o"
              exit 1
          fi

          sudo mv /tmp/nginx-new.conf ${NGINX_CONF}
          rm -f /tmp/nginx-test-inject.conf

          # Verificar y recargar Nginx
          if sudo nginx -t; then
            sudo systemctl reload nginx
            echo "‚úÖ Nginx configurado para /test y OSRM"
          else
            echo "‚ùå Error en configuraci√≥n de Nginx"
            sudo nginx -t
            exit 1
          fi

          # Iniciar aplicaci√≥n con PM2
          echo "üöÄ Iniciando aplicaci√≥n de test..."
          pm2 start start_test_app.sh \
            --name ${APP_NAME} \
            --interpreter bash \
            --cwd ${PROJECT_PATH} \
            --log-date-format "YYYY-MM-DD HH:mm:ss"

          pm2 save

          # Esperar y verificar
          echo "‚è≥ Esperando inicio de la aplicaci√≥n..."
          sleep 8

          # Verificar que PM2 est√© ejecutando el proceso
          echo "üìä Estado de PM2:"
          pm2 status ${APP_NAME}

          # Verificar que el puerto est√© en escucha
          echo "üîç Verificando puerto ${TEST_PORT}..."
          if sudo netstat -tlnp | grep :${TEST_PORT}; then
              echo "‚úÖ Puerto ${TEST_PORT} est√° en escucha"
          else
              echo "‚ùå Puerto ${TEST_PORT} NO est√° en escucha"
              echo ""
              echo "üìã Logs de PM2:"
              pm2 logs ${APP_NAME} --lines 50 --nostream
              echo ""
              echo "üîç Procesos en el puerto ${TEST_PORT}:"
              sudo lsof -i :${TEST_PORT} || echo "Ninguno"
              exit 1
          fi

          # Test de conectividad HTTP
          echo "üß™ Probando aplicaci√≥n HTTP..."
          for i in {1..10}; do
              if curl -s -f http://localhost:${TEST_PORT}/ > /dev/null 2>&1; then
                  echo "‚úÖ Aplicaci√≥n respondiendo en puerto ${TEST_PORT}"
                  echo "üåê URL p√∫blica: https://${FULL_DOMAIN}/test/"
                  exit 0
              fi
              echo "Intento $i/10 - esperando..."
              sleep 2
          done

          echo "‚ùå La aplicaci√≥n no responde despu√©s de m√∫ltiples intentos"
          echo ""
          echo "üìã √öltimos logs de la aplicaci√≥n:"
          pm2 logs ${APP_NAME} --lines 100 --nostream
          echo ""
          echo "üîç Estado detallado de PM2:"
          pm2 describe ${APP_NAME}
          exit 1

          # Resumen final
          echo ""
          echo "========================================="
          echo "üéâ AMBIENTE DE TEST DESPLEGADO"
          echo "========================================="
          echo ""
          echo "üìä INFORMACI√ìN:"
          echo "   - Persona: ${PERSON_NAME}"
          echo "   - Rama: ${BRANCH_NAME}"
          echo "   - Instancia EC2: ${INSTANCE_NUM}"
          echo "   - Aplicaci√≥n PM2: ${APP_NAME}"
          echo "   - Puerto interno: ${TEST_PORT}"
          echo "   - OSRM: http://localhost:5001 (Puerto de Barranquilla)"
          echo ""
          echo "üîó URLS:"
          echo "   - Producci√≥n (main): https://${FULL_DOMAIN}/"
          echo "   - Test (${BRANCH_NAME}): https://${FULL_DOMAIN}/test"
          echo ""
          echo "üìç ENDPOINTS DE TEST:"
          echo "   - https://${FULL_DOMAIN}/test/coordenadas"
          echo "   - https://${FULL_DOMAIN}/test/database"
          echo "   - https://${FULL_DOMAIN}/test/version"
          echo "   - https://${FULL_DOMAIN}/test/health"
          echo ""
          echo "üõ†Ô∏è COMANDOS √öTILES:"
          echo "   - Ver logs test: pm2 logs ${APP_NAME}"
          echo "   - Reiniciar test: pm2 restart ${APP_NAME}"
          echo "   - Ver logs prod: pm2 logs flask-app-${SUBDOMAIN}"
          echo "   - Estado: pm2 status"
          echo "   - OSRM logs: docker logs -f osrm-backend"
          echo ""
          echo "üó∫Ô∏è OSRM configurado para Puerto de Barranquilla"
          echo "   M√©todo: Overpass API con IDs espec√≠ficos"
          echo "   Cobertura: ~75 calles del puerto + 6 nodos clave"
          echo "========================================="
          DEPLOYEOF

          # Transferir scripts
          echo "üì§ Transfiriendo archivos al servidor..."
          scp -o StrictHostKeyChecking=no -i deploy_key setup_osrm.sh ${USER}@${HOST}:/tmp/
          scp -o StrictHostKeyChecking=no -i deploy_key temp_env_file ${USER}@${HOST}:/tmp/test_env_file
          scp -o StrictHostKeyChecking=no -i deploy_key temp_sdk.json ${USER}@${HOST}:/tmp/firebase-admin-sdk.json
          scp -o StrictHostKeyChecking=no -i deploy_key deploy_test_remote.sh ${USER}@${HOST}:/tmp/

          # Ejecutar instalaci√≥n/verificaci√≥n de OSRM PRIMERO
          echo ""
          echo "üó∫Ô∏è ========================================="
          echo "üó∫Ô∏è PASO 1: CONFIGURAR OSRM (PUERTO)"
          echo "üó∫Ô∏è ========================================="
          ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} \
            "chmod +x /tmp/setup_osrm.sh && /tmp/setup_osrm.sh"

          # Ejecutar despliegue de la aplicaci√≥n
          echo ""
          echo "üöÄ ========================================="
          echo "üöÄ PASO 2: DESPLEGAR APLICACI√ìN"
          echo "üöÄ ========================================="
          ssh -o StrictHostKeyChecking=no -i deploy_key ${USER}@${HOST} \
            "chmod +x /tmp/deploy_test_remote.sh && \
             /tmp/deploy_test_remote.sh '${NAME_LOWER}' '${DOMAIN_BASE}' '${INSTANCE_NUM}' '${BRANCH_NAME}' '${PERSON_NAME}' && \
             if [ -f /tmp/test_env_file ]; then \
               if [ -d /home/ubuntu/Web-server-UDP/test/Proyecto_1_Diseno ]; then \
                 mv /tmp/test_env_file /home/ubuntu/Web-server-UDP/test/Proyecto_1_Diseno/.env; \
               else \
                 mv /tmp/test_env_file /opt/location-tracker/test/Proyecto_1_Diseno/.env; \
               fi; \
             fi; \
             if [ -f /tmp/firebase-admin-sdk.json ]; then \
               if [ -d /home/ubuntu/Web-server-UDP/test/Proyecto_1_Diseno ]; then \
                 mv /tmp/firebase-admin-sdk.json /home/ubuntu/Web-server-UDP/test/Proyecto_1_Diseno/firebase-admin-sdk.json; \
               else \
                 mv /tmp/firebase-admin-sdk.json /opt/location-tracker/test/Proyecto_1_Diseno/firebase-admin-sdk.json; \
               fi; \
             fi; \
             rm -f /tmp/deploy_test_remote.sh /tmp/setup_osrm.sh"

          # Limpiar archivos temporales locales
          rm -f deploy_key temp_env_file deploy_test_remote.sh setup_osrm.sh temp_sdk.json

          echo ""
          echo "========================================="
          echo "‚úÖ DESPLIEGUE COMPLETADO"
          echo "========================================="
          echo ""
          echo "üéâ ${PERSON_NAME} puede ver sus cambios en:"
          echo "   üì± https://${FULL_DOMAIN}/test"
          echo ""
          echo "üó∫Ô∏è OSRM (Snap-to-Roads) configurado:"
          echo "   ‚úÖ M√©todo: Overpass API"
          echo "   ‚úÖ Fuente: OpenStreetMap (IDs espec√≠ficos)"

          echo "========================================"
