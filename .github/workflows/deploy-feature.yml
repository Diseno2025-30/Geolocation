name: Deploy Feature Branch to Test

on:
  push:
    branches:
      - Oliver-branch
      - Hernando-branch
      - Alan-branch
      - Sebastian-branch
  workflow_dispatch:
    inputs:
      branch:
        description: "Feature branch to deploy"
        required: true
        type: choice
        options:
          - Oliver-branch
          - Hernando-branch
          - Alan-branch
          - Sebastian-branch

jobs:
  deploy-feature:
    # Determinar el runner según la rama
    runs-on: |
      ${{
        (github.event_name == 'push' && github.ref_name == 'Oliver-branch') || 
        (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'Oliver-branch')
        && fromJSON('["self-hosted", "EC2", "Oliver"]') ||
        (github.event_name == 'push' && github.ref_name == 'Hernando-branch') || 
        (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'Hernando-branch')
        && fromJSON('["self-hosted", "EC2", "Hernando"]') ||
        (github.event_name == 'push' && github.ref_name == 'Alan-branch') || 
        (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'Alan-branch')
        && fromJSON('["self-hosted", "EC2", "Alan"]') ||
        (github.event_name == 'push' && github.ref_name == 'Sebastian-branch') || 
        (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'Sebastian-branch')
        && fromJSON('["self-hosted", "EC2", "Sebastian"]') ||
        'ubuntu-latest'
      }}

    steps:
      - name: Determine target instance
        id: determine-instance
        run: |
          # Determinar la rama actual
          if [ "${{ github.event_name }}" = "push" ]; then
            BRANCH_NAME="${{ github.ref_name }}"
          else
            BRANCH_NAME="${{ github.event.inputs.branch }}"
          fi

          echo "Branch to deploy: ${BRANCH_NAME}"

          # Mapear rama a instancia y persona
          case "${BRANCH_NAME}" in
            "Oliver-branch")
              INSTANCE_NUM=1
              PERSON_NAME="Oliver"
              ;;
            "Hernando-branch")
              INSTANCE_NUM=2
              PERSON_NAME="Hernando"
              ;;
            "Alan-branch")
              INSTANCE_NUM=3
              PERSON_NAME="Alan"
              ;;
            "Sebastian-branch")
              INSTANCE_NUM=4
              PERSON_NAME="Sebastian"
              ;;
            *)
              echo "❌ Rama no reconocida: ${BRANCH_NAME}"
              exit 1
              ;;
          esac

          echo "TARGET_INSTANCE=${INSTANCE_NUM}" >> $GITHUB_OUTPUT
          echo "BRANCH_NAME=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "PERSON_NAME=${PERSON_NAME}" >> $GITHUB_OUTPUT

          echo "🏠 SELF-HOSTED: Desplegando ${BRANCH_NAME} localmente en instancia ${INSTANCE_NUM}"

      - name: Verify EC2 instance
        run: |
          echo "🔍 Verificando instancia EC2..."
          INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id 2>/dev/null || echo "No disponible")
          HOSTNAME=$(hostname)
          PERSON="${{ steps.determine-instance.outputs.PERSON_NAME }}"
          BRANCH="${{ steps.determine-instance.outputs.BRANCH_NAME }}"
          
          echo "📍 Instance ID: $INSTANCE_ID"
          echo "📍 Hostname: $HOSTNAME"
          echo "📍 Persona: $PERSON"
          echo "📍 Rama: $BRANCH"
          echo "✅ Ejecutando en modo SELF-HOSTED para $PERSON"

      - name: Checkout branch
        uses: actions/checkout@v3
        with:
          ref: ${{ steps.determine-instance.outputs.BRANCH_NAME }}

      - name: Deploy to local instance (Self-Hosted)
        env:
          # Usar el secreto correspondiente según la instancia
          ENV_FILE: ${{ secrets[format('ENV_FILE_{0}', steps.determine-instance.outputs.TARGET_INSTANCE)] }}
          DOMAIN_BASE: tumaquinaya.com
          BRANCH_NAME: ${{ steps.determine-instance.outputs.BRANCH_NAME }}
          PERSON_NAME: ${{ steps.determine-instance.outputs.PERSON_NAME }}
          INSTANCE_NUM: ${{ steps.determine-instance.outputs.TARGET_INSTANCE }}
        run: |
          echo "🚀 SELF-HOSTED: Desplegando ${BRANCH_NAME} localmente"

          # Crear archivo .env temporal
          echo "$ENV_FILE" > /tmp/test_env_file

          # Extraer NAME del .env y validar
          NAME_VALUE=$(grep "^NAME=" /tmp/test_env_file | cut -d'=' -f2 | tr -d '"' | tr -d "'" | xargs)
          NAME_LOWER=$(echo "$NAME_VALUE" | tr '[:upper:]' '[:lower:]')
          PERSON_LOWER=$(echo "$PERSON_NAME" | tr '[:upper:]' '[:lower:]')

          if [ "${NAME_LOWER}" != "${PERSON_LOWER}" ]; then
              echo "⚠️ ADVERTENCIA: El NAME en .env (${NAME_VALUE}) no coincide con ${PERSON_NAME}"
          fi

          FULL_DOMAIN="${NAME_LOWER}.${DOMAIN_BASE}"

          echo "📋 Configuración:"
          echo "   - Rama: ${BRANCH_NAME}"
          echo "   - Persona: ${PERSON_NAME}"
          echo "   - Instancia: ${INSTANCE_NUM}"
          echo "   - Dominio: ${FULL_DOMAIN}"
          echo "   - Modo: SELF-HOSTED (local)"

          # Crear script de despliegue local
          cat > /tmp/deploy_test_local.sh << 'DEPLOYEOF'
          #!/bin/bash
          set -e

          SUBDOMAIN="${1}"
          DOMAIN_BASE="${2}"
          INSTANCE_NUM="${3}"
          BRANCH_NAME="${4}"
          PERSON_NAME="${5}"

          echo "🔧 Configuración de despliegue /test (SELF-HOSTED):"
          echo "   - Rama: ${BRANCH_NAME}"
          echo "   - Persona: ${PERSON_NAME}"
          echo "   - Subdominio: ${SUBDOMAIN}"
          echo "   - Dominio: ${SUBDOMAIN}.${DOMAIN_BASE}"
          echo "   - Instancia: ${INSTANCE_NUM}"

          # Detectar el directorio base correcto
          if [ -d "/home/ubuntu/Web-server-UDP" ]; then
            BASE_DIR="/home/ubuntu/Web-server-UDP"
          elif [ -d "/opt/location-tracker" ]; then
            BASE_DIR="/opt/location-tracker"
          else
            # Crear directorio si no existe
            BASE_DIR="/opt/location-tracker"
            sudo mkdir -p ${BASE_DIR}
            sudo chown $USER:$USER ${BASE_DIR}
          fi

          TEST_DIR="${BASE_DIR}/test"
          mkdir -p "${TEST_DIR}"
          cd "${TEST_DIR}"

          echo "📁 Directorio de test: ${TEST_DIR}"

          # Actualizar o clonar el repositorio
          if [ -d .git ]; then
            echo "📦 Actualizando código de la rama ${BRANCH_NAME}..."
            git fetch origin ${BRANCH_NAME}
            git checkout ${BRANCH_NAME}
            git reset --hard origin/${BRANCH_NAME}
            CODE_UPDATED=true
          else
            echo "📥 Clonando repositorio en rama ${BRANCH_NAME}..."
            git clone -b ${BRANCH_NAME} https://github.com/Diseno2025-30/Geolocation.git .
            CODE_UPDATED=true
          fi

          # Navegar al directorio del proyecto
          cd Proyecto_1_Diseno
          PROJECT_PATH=$(pwd)

          # Copiar .env de producción si existe como base
          if [ -f "${BASE_DIR}/Proyecto_1_Diseno/.env" ]; then
            cp "${BASE_DIR}/Proyecto_1_Diseno/.env" .env
          fi

          # Agregar configuración específica de test
          echo "" >> .env
          echo "# Configuración de test" >> .env
          echo "TEST_MODE=true" >> .env
          echo "BRANCH_NAME=${BRANCH_NAME}" >> .env
          echo "PERSON_NAME=${PERSON_NAME}" >> .env
          echo "DEPLOYMENT_DATE=$(date)" >> .env

          FULL_DOMAIN="${SUBDOMAIN}.${DOMAIN_BASE}"
          APP_NAME="flask-test-${SUBDOMAIN}"
          TEST_PORT=6000

          echo "📊 Configuración de aplicación:"
          echo "   - APP_NAME: ${APP_NAME}"
          echo "   - Puerto test: ${TEST_PORT}"
          echo "   - Proyecto: ${PROJECT_PATH}"

          # Instalar dependencias del sistema
          echo "📦 Instalando dependencias del sistema..."
          sudo apt-get update -qq
          sudo apt-get install -y python3-pip python3-venv nginx

          # Instalar PM2 si no existe
          if ! command -v pm2 &> /dev/null; then
            echo "📦 Instalando PM2..."
            if ! command -v node &> /dev/null; then
              curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
              sudo apt-get install -y nodejs
            fi
            sudo npm install -g pm2
            pm2 startup systemd -u ubuntu --hp /home/ubuntu
          fi

          # Configurar entorno Python
          echo "🐍 Configurando entorno Python para test..."
          if [ ! -d "venv" ]; then
            python3 -m venv venv
          fi

          source venv/bin/activate
          pip install --upgrade pip
          pip install flask psycopg2-binary python-dotenv

          # Instalar requirements si existe
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi

          # Detener aplicación existente si está corriendo
          pm2 stop ${APP_NAME} 2>/dev/null || true
          pm2 delete ${APP_NAME} 2>/dev/null || true
          sudo fuser -k ${TEST_PORT}/tcp 2>/dev/null || true
          sleep 2

          # Crear script de inicio
          cat > start_test_app.sh << STARTSCRIPT
          #!/bin/bash
          cd "\$(dirname "\$0")"
          source venv/bin/activate
          export FLASK_APP=udp_flask_server.py
          export FLASK_ENV=development
          python udp_flask_server.py --port ${TEST_PORT}
          STARTSCRIPT
          chmod +x start_test_app.sh

          # Configurar Nginx
          echo "🌐 Configurando Nginx para /test..."
          NGINX_CONF="/etc/nginx/sites-available/location-tracker"
          
          # Verificar si el archivo existe, si no, crearlo
          if [ ! -f ${NGINX_CONF} ]; then
            echo "Creando archivo de configuración Nginx..."
            sudo tee ${NGINX_CONF} > /dev/null << NGINX_BASE
          server {
              listen 80;
              server_name ${SUBDOMAIN}.${DOMAIN_BASE};
              return 301 https://\$server_name\$request_uri;
          }

          server {
              listen 443 ssl;
              server_name ${SUBDOMAIN}.${DOMAIN_BASE};

              ssl_certificate /etc/letsencrypt/live/${SUBDOMAIN}.${DOMAIN_BASE}/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/${SUBDOMAIN}.${DOMAIN_BASE}/privkey.pem;

              location / {
                  proxy_pass http://localhost:5000;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
              }
          }
          NGINX_BASE
            sudo ln -sf ${NGINX_CONF} /etc/nginx/sites-enabled/
          fi

          # Eliminar configuración de test anterior
          sudo sed -i '/# ===== INICIO RUTAS TEST/,/# ===== FIN RUTAS TEST/d' ${NGINX_CONF}

          # Crear archivo temporal con la nueva configuración de test
          cat > /tmp/nginx-test-inject.conf << NGINXTEST

          # ===== INICIO RUTAS TEST =====
          # Rama: ${BRANCH_NAME} - Persona: ${PERSON_NAME}
          # Actualizado: $(date)

          location = /test {
              return 301 /test/;
          }

          location /test/ {
              proxy_pass http://localhost:${TEST_PORT}/;
              proxy_set_header Host \$host;
              proxy_set_header X-Real-IP \$remote_addr;
              proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto \$scheme;
              proxy_set_header X-Script-Name /test;
              proxy_connect_timeout 60s;
              proxy_send_timeout 60s;
              proxy_read_timeout 60s;
              proxy_buffering off;
          }

          location ~ ^/test/(coordenadas|database|version|health)$ {
              proxy_pass http://localhost:${TEST_PORT}/\$1;
              proxy_set_header Host \$host;
              proxy_set_header X-Real-IP \$remote_addr;
              proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto \$scheme;
          }

          location /test/static/ {
              alias ${PROJECT_PATH}/static/;
              expires 30d;
              add_header Cache-Control "public, immutable";
          }

          # ===== FIN RUTAS TEST =====

          NGINXTEST

          # Inyectar la configuración de test en el archivo de Nginx
          sudo awk '
          /location \/ \{/ {
              while ((getline line < "/tmp/nginx-test-inject.conf") > 0)
                  print line
              close("/tmp/nginx-test-inject.conf")
          }
          { print }
          ' ${NGINX_CONF} > /tmp/nginx-new.conf

          sudo mv /tmp/nginx-new.conf ${NGINX_CONF}
          rm -f /tmp/nginx-test-inject.conf

          # Validar y recargar Nginx
          if sudo nginx -t; then
            sudo systemctl reload nginx
            echo "✅ Nginx configurado correctamente para /test"
          else
            echo "❌ Error en configuración de Nginx"
            sudo nginx -t
            exit 1
          fi

          # Iniciar aplicación con PM2
          echo "🚀 Iniciando aplicación de test..."
          pm2 start start_test_app.sh \
            --name ${APP_NAME} \
            --interpreter bash \
            --cwd ${PROJECT_PATH} \
            --log-date-format "YYYY-MM-DD HH:mm:ss"

          pm2 save

          # Esperar y verificar
          echo "⏳ Esperando inicio de la aplicación..."
          sleep 5

          echo "📊 Estado de la aplicación:"
          pm2 status ${APP_NAME}

          # Probar la aplicación
          echo "🧪 Probando aplicación..."
          if curl -s -f http://localhost:${TEST_PORT}/ > /dev/null 2>&1; then
            echo "✅ Aplicación respondiendo correctamente en puerto ${TEST_PORT}"
          else
            echo "⚠️ La aplicación podría no estar respondiendo"
            echo "Últimos logs:"
            pm2 logs ${APP_NAME} --lines 20 --nostream
          fi

          # Probar endpoint de test via Nginx
          echo "🧪 Probando ruta /test via Nginx..."
          if curl -s -f http://localhost/test/ > /dev/null 2>&1; then
            echo "✅ Ruta /test funcionando correctamente"
          else
            echo "⚠️ La ruta /test podría no estar funcionando"
          fi

          echo ""
          echo "========================================="
          echo "🎉 AMBIENTE DE TEST DESPLEGADO (SELF-HOSTED)"
          echo "========================================="
          echo ""
          echo "📊 INFORMACIÓN DEL DESPLIEGUE:"
          echo "   - Persona: ${PERSON_NAME}"
          echo "   - Rama: ${BRANCH_NAME}"
          echo "   - Instancia EC2: #${INSTANCE_NUM}"
          echo "   - Aplicación PM2: ${APP_NAME}"
          echo "   - Puerto interno: ${TEST_PORT}"
          echo "   - Directorio: ${PROJECT_PATH}"
          echo "   - Modo: LOCAL (sin SSH)"
          echo ""
          echo "🔗 URLS DISPONIBLES:"
          echo "   - Producción (main): https://${FULL_DOMAIN}/"
          echo "   - Test (${BRANCH_NAME}): https://${FULL_DOMAIN}/test"
          echo ""
          echo "📍 ENDPOINTS DE TEST:"
          echo "   - https://${FULL_DOMAIN}/test/"
          echo "   - https://${FULL_DOMAIN}/test/coordenadas"
          echo "   - https://${FULL_DOMAIN}/test/database"
          echo "   - https://${FULL_DOMAIN}/test/version"
          echo "   - https://${FULL_DOMAIN}/test/health"
          echo ""
          echo "🛠️ COMANDOS ÚTILES:"
          echo "   - Ver logs test: pm2 logs ${APP_NAME}"
          echo "   - Reiniciar test: pm2 restart ${APP_NAME}"
          echo "   - Detener test: pm2 stop ${APP_NAME}"
          echo "   - Ver logs prod: pm2 logs flask-app-${SUBDOMAIN}"
          echo "   - Estado general: pm2 status"
          echo ""
          echo "📝 NOTAS:"
          echo "   - El ambiente de test se actualiza automáticamente con cada push a ${BRANCH_NAME}"
          echo "   - Los archivos estáticos se sirven desde ${PROJECT_PATH}/static/"
          echo "   - El .env incluye TEST_MODE=true para diferenciar de producción"
          echo "========================================="
          DEPLOYEOF

          chmod +x /tmp/deploy_test_local.sh

          # Ejecutar localmente (sin SSH)
          /tmp/deploy_test_local.sh "${NAME_LOWER}" "${DOMAIN_BASE}" "${INSTANCE_NUM}" "${BRANCH_NAME}" "${PERSON_NAME}"

          # Mover el archivo .env a su ubicación final
          if [ -f /tmp/test_env_file ]; then
            if [ -d "/home/ubuntu/Web-server-UDP/test/Proyecto_1_Diseno" ]; then
              mv /tmp/test_env_file /home/ubuntu/Web-server-UDP/test/Proyecto_1_Diseno/.env
            elif [ -d "/opt/location-tracker/test/Proyecto_1_Diseno" ]; then
              mv /tmp/test_env_file /opt/location-tracker/test/Proyecto_1_Diseno/.env
            fi
          fi

          # Limpiar
          rm -f /tmp/deploy_test_local.sh

          echo "✅ Despliegue SELF-HOSTED completado para ${PERSON_NAME}"

      - name: Send notification
        if: always()
        run: |
          PERSON_NAME="${{ steps.determine-instance.outputs.PERSON_NAME }}"
          BRANCH_NAME="${{ steps.determine-instance.outputs.BRANCH_NAME }}"
          STATUS="${{ job.status }}"
          
          if [ "$STATUS" = "success" ]; then
            echo "✅ Despliegue exitoso de ${BRANCH_NAME} para ${PERSON_NAME}"
            echo "🔗 Accede a tu ambiente de test en: https://${PERSON_NAME,,}.tumaquinaya.com/test"
          else
            echo "❌ Fallo en el despliegue de ${BRANCH_NAME} para ${PERSON_NAME}"
          fi